================================================================================
АРХИТЕКТУРА ПРОЕКТА
================================================================================

└── C:\
    └── Users
        └── User
            └── Desktop
                └── gotovo
                    └── integrated_project
                        ├── start_system.bat
                        ├── guardian_angel_front
                        │   ├── index.html
                        │   ├── history.html
                        │   ├── js
                        │   │   ├── api.js
                        │   │   ├── app.js
                        │   │   ├── charts.js
                        │   │   ├── data.js
                        │   │   └── history.js
                        │   └── css
                        │       └── style.css
                        ├── guardian_angel
                        │   ├── ml_model.pkl
                        │   ├── main.py
                        │   ├── guardian_angel_data.db
                        │   ├── final_prediction_service.py
                        │   ├── db_manager.py
                        │   ├── client_main.py
                        │   └── api.py
                        └── device_emulator
                            └── main.py

================================================================================
СОДЕРЖИМОЕ ФАЙЛОВ
================================================================================


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\start_system.bat
================================================================================

@echo off
chcp 65001 >nul
title Guardian Angel - Complete System

echo [INFO] Starting Guardian Angel System
echo ==========================================
echo [INFO] Working directory: %CD%
echo.

REM Define paths
set "EMULATOR_PATH=device_emulator"
set "BACKEND_PATH=guardian_angel"
set "FRONTEND_PATH=guardian_angel_front"

REM Check if directories exist
echo [INFO] Checking paths...
if not exist "%EMULATOR_PATH%" (
    echo [ERROR] Emulator folder not found: %EMULATOR_PATH%
    pause
    exit /b 1
)

if not exist "%BACKEND_PATH%" (
    echo [ERROR] Guardian Angel folder not found: %BACKEND_PATH%
    pause
    exit /b 1
)

if not exist "%FRONTEND_PATH%" (
    echo [ERROR] Frontend folder not found: %FRONTEND_PATH%
    pause
    exit /b 1
)

echo [INFO] All paths found.
echo.

REM Check for Python
python --version >nul 2>&1
if errorlevel 1 (
    echo [ERROR] Python is not installed or not in PATH.
    pause
    exit /b 1
)

echo [INFO] Launching components in sequence...
echo.

REM 1. START DATA EMULATOR (from device_emulator)
echo 1. [EMULATOR] Starting data emulator...
start "CTG Data Emulator" cmd /k "cd /d "%EMULATOR_PATH%" && python main.py && echo Emulator stopped && pause"

echo    [INFO] Waiting for emulator to start (3 sec)...
timeout /t 3 /nobreak >nul

REM 2. START API SERVER (from guardian_angel)
echo 2. [API] Starting API server...
start "Guardian Angel API" cmd /k "cd /d "%BACKEND_PATH%" && uvicorn api:app --reload --host 0.0.0.0 --port 8000 && echo API server stopped && pause"

echo    [INFO] Waiting for API to start (5 sec)...
timeout /t 5 /nobreak >nul

REM 3. START FRONTEND (from guardian_angel_front)
echo 3. [FRONTEND] Starting frontend...
start "Guardian Angel Frontend" cmd /k "cd /d "%FRONTEND_PATH%" && python -m http.server 8080 && echo Frontend stopped && pause"

echo    [INFO] Waiting for frontend to start (3 sec)...
timeout /t 3 /nobreak >nul

echo.
echo [SUCCESS] ALL COMPONENTS LAUNCHED!
echo ==========================================
echo [INFO] Launch sequence:
echo    1. [EMULATOR] Data Emulator (generates CTG data)
echo    2. [API] API Server (handles requests and ML analysis)
echo    3. [FRONTEND] Web Interface (user interface)
echo.
echo [INFO] Available addresses:
echo    * Frontend: http://localhost:8080
echo    * API: http://localhost:8000
echo    * API Docs: http://localhost:8000/docs
echo    * WebSocket: ws://localhost:8000/ws
echo.
echo [INFO] Opening frontend in browser...
start http://localhost:8080
echo.
echo [INFO] To check system operation:
echo    1. Browser should open automatically at http://localhost:8080
echo    2. Ensure data is displayed on charts
echo    3. Check API status at http://localhost:8000/status
echo.
echo [INFO] To stop all services, close all CMD windows or press Ctrl+C in each window.
echo.
pause


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\guardian_angel_front\index.html
================================================================================

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Медицинский мониторинг КТГ - Дашборд</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    
    <!-- Styles -->
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <main class="dashboard">
        <!-- Header Section -->
        <header class="dashboard__header card">
            <div class="patient-info">
                <div class="patient-info__label">ПАЦИЕНТ</div>
                <div class="patient-info__data">
                    <div class="patient-info__field">
                        <span class="patient-info__value">Милюкова Мария Ивановна</span>
                        <span class="patient-info__caption">ФИО</span>
                    </div>
                    <div class="patient-info__field">
                        <span class="patient-info__value">28 Недель</span>
                        <span class="patient-info__caption">СРОК</span>
                    </div>
                </div>
            </div>
            <button class="btn btn--outline" aria-label="История пациента" onclick="location.href='history.html'">
                ИСТОРИЯ
            </button>
        </header>

        <!-- Wellbeing Index Card -->
        <section class="dashboard__wellbeing card card--no-padding">
            <div class="card__header card__header--blue">
                <h3 class="card__title">Индекс благополучия</h3>
            </div>
            <div class="card__content">
                <div class="wellbeing">
                    <div class="wellbeing__chart">
                        <canvas id="wellbeingChart" width="160" height="160"></canvas>
                    </div>
                    <div class="wellbeing__diseases">
                        <ul class="diseases-list">
                            <li class="diseases-list__item">
                                <span class="diseases-list__name">ДИАБЕТ</span>
                                <span class="diseases-list__status">I СТЕПЕНИ</span>
                            </li>
                            <li class="diseases-list__item">
                                <span class="diseases-list__name">ОЖИРЕНИЕ</span>
                                <span class="diseases-list__status diseases-list__status--none">Нет</span>
                            </li>
                            <li class="diseases-list__item">
                                <span class="diseases-list__name">ГИПЕРТОНИЯ</span>
                                <span class="diseases-list__status">II СТЕПЕНИ</span>
                            </li>
                            <li class="diseases-list__item">
                                <span class="diseases-list__name">АНЕМИЯ</span>
                                <span class="diseases-list__status diseases-list__status--none">Нет</span>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Events Card - Updated with blue header -->
        <section class="dashboard__events card card--no-padding">
            <div class="card__header card__header--blue">
                <h3 class="card__title">События</h3>
                <span class="card__subtitle">Время (мин)</span>
            </div>
            <div class="card__content">
                <div class="events">
                    <div class="events__list" id="eventsList">
                        <!-- Events will be populated from JS -->
                    </div>
                </div>
            </div>
        </section>

        <!-- KTG Chart Card with Separate Charts -->
        <section class="dashboard__ktg card">
            <div class="ktg">
                <div class="ktg__header">
                    <h2 class="ktg__title">Кардиотокография (КТГ)</h2>
                    <div class="ktg__controls">
                        <button class="ktg__print-btn" title="Печать">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M6 9V2h12v7M6 18H4a2 2 0 01-2-2v-5a2 2 0 012-2h16a2 2 0 012 2v5a2 2 0 01-2 2h-2M6 14h12v8H6z"/>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <!-- FHR Chart (Top) -->
                <div class="ktg__chart-group">
                    <div class="ktg__chart-label">
                        <span class="ktg__chart-title">ЧСС</span>
                        <span class="ktg__chart-units">уд/мин</span>
                    </div>
                    <div class="ktg__chart-container ktg__chart-container--fhr">
                        <canvas id="fhrChart"></canvas>
                    </div>
                </div>
                
                <!-- UA Chart (Bottom) -->
                <div class="ktg__chart-group">
                    <div class="ktg__chart-label">
                        <span class="ktg__chart-title">СДМ</span>
                        <span class="ktg__chart-units">отн.ед</span>
                    </div>
                    <div class="ktg__chart-container ktg__chart-container--ua">
                        <canvas id="uaChart"></canvas>
                    </div>
                </div>
                
                <!-- Timeline Controls -->
                <div class="ktg__timeline">
                    <div class="ktg__time-start">
                        <span>НАЧАЛО</span>
                        <span id="startTime">14:00:00</span>
                    </div>
                    <div class="ktg__scrubber" id="scrubber">
                        <div class="ktg__scrubber-track"></div>
                        <div class="ktg__scrubber-handle" id="scrubberHandle">
                            <div class="ktg__scrubber-time" id="currentTime">14:00</div>
                        </div>
                    </div>
                    <div class="ktg__time-end">
                        <span>КОНЕЦ</span>
                        <span id="endTime">17:00:00</span>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- JavaScript -->

    <script src="js/data.js"></script>
    <script src="js/charts.js"></script>
    <script src="js/app.js"></script>
  

</body>
</html>


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\guardian_angel_front\history.html
================================================================================

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>История записей - Медицинский мониторинг КТГ</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    
    <!-- Styles -->
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <main class="history-page">
        <!-- Header with navigation -->
        <header class="history-page__header">
            <div class="history-page__nav">
                <a href="index.html" class="btn-back">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <path d="M19 12H5M5 12L12 19M5 12L12 5"/>
                    </svg>
                    <span>Назад к мониторингу</span>
                </a>
            </div>
            <h1 class="history-page__title">История записей КТГ</h1>
            <div class="history-page__filters">
                <input type="date" id="dateFilter" class="date-filter" />
                <button class="btn btn--secondary" id="clearFilter">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                    <span>Сбросить</span>
                </button>
            </div>
        </header>

        <!-- Sessions list -->
        <div class="history-sessions" id="historySessions">
            <!-- Sessions will be dynamically inserted here -->
        </div>

        <!-- Empty state placeholder -->
        <div class="history-placeholder" id="placeholderState">
            <div class="history-placeholder__icon">
                <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M9 11l3 3L22 4"/>
                    <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"/>
                </svg>
            </div>
            <h3 class="history-placeholder__title">Загрузка данных...</h3>
            <p class="history-placeholder__text">Данные временно недоступны. Отображаются демонстрационные записи</p>
        </div>
    </main>

    <!-- JavaScript -->
    <script src="js/data.js"></script>
    <script src="js/charts.js"></script>
    <script src="js/history.js"></script>
</body>
</html>


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\guardian_angel_front\js\api.js
================================================================================

from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import asyncio
import json
import time
import logging
from datetime import datetime

from .ctg_simulator import CTGSimulator
from .ml_processor import MLProcessor
from .data_store import DataStore

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Глобальные переменные для хранения состояния
simulator = None
ml_processor = None
db = None
active_connections = []
background_task = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Управление жизненным циклом приложения"""
    global simulator, ml_processor, db, background_task
    
    # Инициализация при запуске
    logger.info("🚀 Запуск Guardian Angel API...")
    
    simulator = CTGSimulator()
    ml_processor = MLProcessor()
    db = DataStore()
    
    # Запуск фоновой задачи
    background_task = asyncio.create_task(process_ctg_data())
    
    logger.info("✅ API готов к работе")
    
    yield
    
    # Очистка при остановке
    logger.info("🛑 Остановка Guardian Angel API...")
    
    if background_task:
        background_task.cancel()
        try:
            await background_task
        except asyncio.CancelledError:
            pass
    
    logger.info("👋 API остановлен")

# Создание приложения FastAPI
app = FastAPI(
    title="Guardian Angel API",
    version="1.0.0",
    lifespan=lifespan
)

# Настройка CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

async def process_ctg_data():
    """Фоновая задача для генерации и обработки данных КТГ"""
    while True:
        try:
            # Генерируем новые данные КТГ
            ctg_data = simulator.generate_data()
            
            # Сохраняем в базу
            db.add(ctg_data)
            
            # Получаем последние данные для анализа
            recent_data = db.get(limit=30)
            
            # ML анализ
            if len(recent_data) >= 10:
                prediction = ml_processor.predict(recent_data)
                
                # Отправляем данные всем подключенным клиентам
                await broadcast_to_clients({
                    "type": "ctg_data",
                    "data": ctg_data
                })
                
                # Отправляем предсказания
                await broadcast_to_clients({
                    "type": "prediction",
                    "data": prediction
                })
                
                # Проверяем на критические состояния
                if prediction['fetal_wellbeing_index'] < 70:
                    await broadcast_to_clients({
                        "type": "alert",
                        "severity": "warning" if prediction['fetal_wellbeing_index'] >= 50 else "critical",
                        "message": f"Внимание! Индекс благополучия плода: {prediction['fetal_wellbeing_index']}%",
                        "data": prediction
                    })
            
            # Ждем перед следующей итерацией
            await asyncio.sleep(1)
            
        except Exception as e:
            logger.error(f"Ошибка в процессе обработки данных: {e}")
            await asyncio.sleep(1)

async def broadcast_to_clients(message):
    """Отправка сообщения всем подключенным клиентам"""
    if active_connections:
        message_json = json.dumps(message)
        disconnected = []
        
        for connection in active_connections:
            try:
                await connection.send_text(message_json)
            except Exception as e:
                logger.error(f"Ошибка отправки сообщения клиенту: {e}")
                disconnected.append(connection)
        
        # Удаляем отключенные соединения
        for conn in disconnected:
            if conn in active_connections:
                active_connections.remove(conn)

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket эндпоинт для real-time обновлений"""
    await websocket.accept()
    active_connections.append(websocket)
    logger.info(f"✅ Новое WebSocket подключение. Всего подключений: {len(active_connections)}")
    
    try:
        while True:
            # Получаем сообщение от клиента
            data = await websocket.receive_text()
            
            # Обрабатываем команды
            if data == "status":
                status = {
                    "type": "status",
                    "connected": True,
                    "simulator_running": simulator is not None,
                    "active_connections": len(active_connections),
                    "data_points": db.count() if db else 0
                }
                await websocket.send_text(json.dumps(status))
            
            elif data.startswith("session:"):
                session_id = data.split(":")[1]
                logger.info(f"Смена сессии на: {session_id}")
                # Здесь можно добавить логику смены сессии
                
    except WebSocketDisconnect:
        active_connections.remove(websocket)
        logger.info(f"🔌 WebSocket отключен. Осталось подключений: {len(active_connections)}")
    except Exception as e:
        logger.error(f"Ошибка WebSocket: {e}")
        if websocket in active_connections:
            active_connections.remove(websocket)

@app.get("/")
async def root():
    """Корневой эндпоинт"""
    return {
        "name": "Guardian Angel API",
        "version": "1.0.0",
        "status": "running"
    }

@app.get("/status")
async def get_status():
    """Получить статус системы"""
    return {
        "status": "running",
        "simulator_active": simulator is not None,
        "ml_processor_active": ml_processor is not None,
        "database_connected": db is not None,
        "active_connections": len(active_connections),
        "data_points": db.count() if db else 0,
        "timestamp": time.time()
    }

@app.get("/ctg_data")
async def get_ctg_data(limit: int = 50):
    """Получить последние данные КТГ"""
    if not db:
        return {"error": "Database not initialized"}
    
    data = db.get(limit=limit)
    return {
        "count": len(data),
        "data": data
    }

@app.get("/predictions/{session_id}")
async def get_predictions(session_id: str = "default"):
    """Получить ML предсказания для сессии"""
    if not db or not ml_processor:
        return {"error": "System not initialized"}
    
    # Получаем последние данные
    recent_data = db.get(limit=30)
    
    if len(recent_data) < 10:
        return {
            "session_id": session_id,
            "status": "insufficient_data",
            "message": "Недостаточно данных для анализа"
        }
    
    # Делаем предсказание
    prediction = ml_processor.predict(recent_data)
    
    return {
        "session_id": session_id,
        "timestamp": time.time(),
        "prediction": prediction
    }

@app.post("/patient/{session_id}/clinical_data")
async def update_clinical_data(session_id: str, clinical_data: dict):
    """Обновить клинические данные пациента"""
    logger.info(f"Обновление клинических данных для сессии {session_id}: {clinical_data}")
    
    # Здесь можно добавить сохранение в базу данных
    # Для примера просто отправляем обновление всем клиентам
    await broadcast_to_clients({
        "type": "clinical_data_updated",
        "session_id": session_id,
        "data": clinical_data
    })
    
    return {
        "status": "success",
        "session_id": session_id,
        "clinical_data": clinical_data
    }

@app.get("/history/sessions")
async def get_history_sessions():
    """Получить список всех сессий мониторинга"""
    try:
        # Получаем все записи из базы данных
        records = db.get(99999)
        
        if not records:
            return []
        
        # Записи идут от новых к старым, поэтому:
        # Первая запись - самая новая (end_ts)
        # Последняя запись - самая старая (start_ts)
        start_ts = records[-1]['ts']  # Самая старая запись
        end_ts = records[0]['ts']     # Самая новая запись
        
        # Конвертируем timestamp в datetime объекты
        start_datetime = datetime.fromtimestamp(start_ts)
        end_datetime = datetime.fromtimestamp(end_ts)
        
        # Рассчитываем длительность в минутах
        duration_mins = int((end_ts - start_ts) / 60)
        
        # Формируем объект сессии
        session = {
            "id": "full_history",
            "date": start_datetime.strftime("%Y-%m-%d"),
            "startTime": start_datetime.strftime("%H:%M"),
            "endTime": end_datetime.strftime("%H:%M"),
            "durationMins": duration_mins,
            "avgFwbs": 85,  # Заглушка
            "fischerScore": 8  # Заглушка
        }
        
        return [session]
        
    except Exception as e:
        logger.error(f"Ошибка при получении сессий: {e}")
        return []

@app.get("/history/session/{session_id}")
async def get_session_details(session_id: str):
    """Получить детальные данные сессии для построения графика"""
    try:
        # Получаем все записи из базы данных
        records = db.get(99999)
        
        if not records:
            return {"data": {"labels": [], "fhr": [], "ua": []}}
        
        # Сортируем записи по возрастанию времени (от старых к новым)
        records.reverse()
        
        # Инициализируем массивы для данных
        labels = []
        fhr = []
        ua = []
        
        # Определяем время начала сессии
        start_ts = records[0]['ts']
        
        # Обрабатываем каждую запись
        for record in records:
            # Рассчитываем время от начала в минутах
            time_from_start = (record['ts'] - start_ts) / 60.0
            labels.append(round(time_from_start, 1))
            
            # Добавляем значения ЧСС и тонуса матки
            fhr.append(record.get('bpm_value', 0))
            ua.append(record.get('uterus_value', 0))
        
        return {
            "data": {
                "labels": labels,
                "fhr": fhr,
                "ua": ua
            }
        }
        
    except Exception as e:
        logger.error(f"Ошибка при получении данных сессии {session_id}: {e}")
        return {"data": {"labels": [], "fhr": [], "ua": []}}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\guardian_angel_front\js\app.js
================================================================================

/**
 * Main application logic for dual-chart CTG display
 */

class KTGDashboard {
    constructor() {
        this.fullData = null;
        this.currentPosition = 0;
        this.isDragging = false;
        this.scrubber = null;
        this.scrubberHandle = null;
        this.scrubberTrack = null;
        this.activeEventIndex = null;
        
        // РЕАЛЬНОЕ ВРЕМЯ - новые настройки
        this.isRealTimeMode = true;
        this.realTimeData = {
            labels: [],
            fhr: [],
            ua: [],
            timestamps: []
        };
        this.maxDataPoints = 180; // 30 минут данных
        this.startTime = Date.now();
        this.autoUpdateInterval = null;
        this.lastDataTime = 0;
        
        // НАСТРОЙКИ ОТОБРАЖЕНИЯ
        this.windowSize = 30; // минут отображаемых на экране
        this.totalDuration = 60; // минут всего данных в памяти
        this.dataPointInterval = 10; // интервал между точками данных (в секундах)
        
        this.init();
    }

    init() {
        console.log('Initializing Real-time CTG Dashboard...');
        
        // Инициализируем WebSocket
        this.setupWebSocket();
        
        // Инициализируем UI компоненты
        this.initializeCharts();
        this.initializeEvents();
        this.initializeScrubber();
        
        // Устанавливаем начальное представление
        this.updateView();
        
        // Запускаем автообновление
        this.startAutoUpdate();
    }

    setupWebSocket() {
        this.socket = new WebSocket('ws://localhost:8000/ws');
        
        this.socket.onopen = () => {
            console.log('✅ WebSocket connected');
            this.updateConnectionStatus(true);
        };

        this.socket.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                console.log('WebSocket message type:', message.type);
                
                // Обрабатываем разные типы сообщений с помощью switch
                switch (message.type) {
                    case 'ctg_data':
                        this.handleCTGData(message.data);
                        break;
                        
                    case 'prediction':
                        this.handlePredictionUpdate(message.data);
                        break;
                        
                    case 'patient_info_updated':
                        this.handlePatientInfoUpdate(message);
                        break;
                        
                    case 'welcome':
                        console.log('Welcome message:', message.message);
                        break;
                        
                    case 'status':
                        console.log('Status update:', message);
                        break;
                        
                    case 'alert':
                        this.handleAlert(message);
                        break;
                        
                    case 'session_ended':
                    case 'new_session_started':
                        this.handleSessionChange(message);
                        break;
                        
                    default:
                        console.log('Unknown message type:', message.type, message);
                }
            } catch (error) {
                console.error('Error parsing WebSocket message:', error);
            }
        };

        this.socket.onclose = () => {
            console.log('❌ WebSocket disconnected');
            this.updateConnectionStatus(false);
            // Пытаемся переподключиться через 3 секунды
            setTimeout(() => this.setupWebSocket(), 3000);
        };

        this.socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.updateConnectionStatus(false);
        };
    }

    handleCTGData(data) {
        const currentTime = Date.now();
        const elapsedMinutes = (currentTime - this.startTime) / 60000;
        
        // Проверяем интервал между точками
        if ((currentTime - this.lastDataTime) < this.dataPointInterval * 1000) {
            return; // Пропускаем точку если не прошло 10 секунд
        }
        
        // Извлекаем значения из данных
        const fhrValue = parseFloat(data.bpm_value || (data.bpm && data.bpm[1]) || 140);
        const uaValue = parseFloat(data.uterus_value || (data.uterus && data.uterus[0]) || 0);
        
        // ДОБАВЛЕНО: Фильтрация аномальных значений ЧСС
        if (fhrValue < 50 || fhrValue > 210) {
            console.warn(`Anomalous FHR value detected: ${fhrValue}, skipping data point`);
            return; // Пропускаем аномальные значения
        }
        
        // Добавляем валидные данные
        this.realTimeData.labels.push(elapsedMinutes);
        this.realTimeData.fhr.push(fhrValue);
        this.realTimeData.ua.push(uaValue);
        this.realTimeData.timestamps.push(new Date(currentTime));
        
        this.lastDataTime = currentTime;

        // Ограничиваем количество точек (скользящее окно)
        if (this.realTimeData.labels.length > this.maxDataPoints) {
            this.realTimeData.labels.shift();
            this.realTimeData.fhr.shift();
            this.realTimeData.ua.shift();
            this.realTimeData.timestamps.shift();
        }
        
        console.log(`Added data point: ${elapsedMinutes.toFixed(1)}min, FHR: ${fhrValue}, UA: ${uaValue}`);
    }

    async handlePredictionUpdate(data) {
        console.log('Prediction update received:', data);
        
        // Обновляем индекс благополучия
        if (data.fetal_wellbeing_index !== undefined) {
            const wellbeingIndex = Math.round(data.fetal_wellbeing_index);
            console.log(`Updating wellbeing index to: ${wellbeingIndex}`);
            
            // Обновляем круговой график благополучия
            if (ChartManager && ChartManager.createWellbeingChart) {
                ChartManager.createWellbeingChart('wellbeingChart', wellbeingIndex);
            }
            
            // Обновляем текстовое значение если есть элемент
            const wellbeingText = document.querySelector('.wellbeing__value');
            if (wellbeingText) {
                wellbeingText.textContent = wellbeingIndex;
            }
        }
        
        // Обновляем список событий если есть detected_patterns
        if (data.detected_patterns && Array.isArray(data.detected_patterns)) {
            this.updateEventsList(data.detected_patterns);
        }
        
        // Обновляем уровень риска если есть
        if (data.risk_level) {
            this.updateRiskLevel(data.risk_level);
        }
        
        // Обновляем рекомендации если есть
        if (data.recommendations && Array.isArray(data.recommendations)) {
            this.updateRecommendations(data.recommendations);
        }
    }

    updateEventsList(patterns) {
        const eventsList = document.getElementById('eventsList');
        if (!eventsList) {
            console.warn('Events list element not found');
            return;
        }
        
        // Очищаем содержимое списка событий
        eventsList.innerHTML = '';
        
        // Если массив пуст, показываем сообщение
        if (!patterns || patterns.length === 0) {
            const placeholder = document.createElement('div');
            placeholder.className = 'events__placeholder';
            placeholder.textContent = 'Нет обнаруженных событий';
            eventsList.appendChild(placeholder);
            return;
        }
        
        // Перебираем паттерны и создаем элементы
        patterns.forEach((pattern, index) => {
            const eventItem = document.createElement('div');
            eventItem.className = 'events__item';
            
            // Определяем тип события и добавляем соответствующий класс
            if (pattern.type === 'acceleration' || pattern.name?.toLowerCase().includes('акцелерация')) {
                eventItem.classList.add('events__item--acceleration');
            } else if (pattern.type === 'deceleration' || pattern.name?.toLowerCase().includes('децелерация')) {
                eventItem.classList.add('events__item--deceleration');
            } else if (pattern.type === 'contraction' || pattern.name?.toLowerCase().includes('схватка')) {
                eventItem.classList.add('events__item--contraction');
            }
            
            // Создаем содержимое события
            const eventName = document.createElement('div');
            eventName.className = 'events__item-name';
            eventName.textContent = pattern.name || pattern.type || 'Событие';
            
            const eventTime = document.createElement('div');
            eventTime.className = 'events__item-time';
            eventTime.textContent = pattern.detected_at_readable || 
                                   pattern.time || 
                                   pattern.displayTime || 
                                   `${Math.round(pattern.start_time || index)} мин`;
            
            eventItem.appendChild(eventName);
            eventItem.appendChild(eventTime);
            
            // Добавляем описание если есть
            if (pattern.description) {
                const eventDesc = document.createElement('div');
                eventDesc.className = 'events__item-description';
                eventDesc.textContent = pattern.description;
                eventItem.appendChild(eventDesc);
            }
            
            // Добавляем обработчик клика для навигации к событию
            eventItem.addEventListener('click', () => {
                console.log('Event clicked:', pattern);
                // Можно добавить навигацию к моменту события на графике
            });
            
            eventsList.appendChild(eventItem);
        });
        
        console.log(`Updated events list with ${patterns.length} patterns`);
    }

    handlePatientInfoUpdate(message) {
        console.log('Patient info update:', message);
        
        // Обновляем ФИО пациента
        if (message.name) {
            const nameElements = document.querySelectorAll('.patient-info__value');
            if (nameElements.length > 0) {
                nameElements[0].textContent = message.name;
            }
            
            // Также обновляем в заголовке если есть
            const headerName = document.querySelector('.dashboard__patient-name');
            if (headerName) {
                headerName.textContent = message.name;
            }
        }
        
        // Обновляем срок беременности
        if (message.week !== undefined && message.week !== null) {
            const weekElements = document.querySelectorAll('.patient-info__value');
            if (weekElements.length > 1) {
                weekElements[1].textContent = `${message.week} недель`;
            }
            
            // Также обновляем в заголовке если есть
            const headerWeek = document.querySelector('.dashboard__patient-week');
            if (headerWeek) {
                headerWeek.textContent = `${message.week} недель`;
            }
        }
        
        // Сохраняем информацию о сессии
        if (message.session_id) {
            this.currentSessionId = message.session_id;
        }
    }

    updateRiskLevel(riskLevel) {
        // Создаем или обновляем индикатор уровня риска
        let riskIndicator = document.getElementById('riskIndicator');
        if (!riskIndicator) {
            // Создаем новый элемент если его нет
            const statsContainer = document.querySelector('.dashboard__stats') || 
                                 document.querySelector('.wellbeing');
            if (statsContainer) {
                riskIndicator = document.createElement('div');
                riskIndicator.id = 'riskIndicator';
                riskIndicator.className = 'risk-indicator';
                statsContainer.appendChild(riskIndicator);
            }
        }
        
        if (riskIndicator) {
            const riskLevels = {
                'low': { text: 'Низкий риск', color: '#2ED47A' },
                'normal': { text: 'Норма', color: '#2ED47A' },
                'medium': { text: 'Средний риск', color: '#FFA500' },
                'high': { text: 'Высокий риск', color: '#FF5B5B' },
                'critical': { text: 'Критический', color: '#FF0000' }
            };
            
            const level = riskLevels[riskLevel] || { text: riskLevel, color: '#666' };
            
            riskIndicator.innerHTML = `
                <span class="risk-indicator__label">Уровень риска:</span>
                <span class="risk-indicator__value" style="color: ${level.color}">
                    ${level.text}
                </span>
            `;
        }
    }

    updateRecommendations(recommendations) {
        // Находим или создаем блок рекомендаций
        let recsBlock = document.getElementById('recommendations');
        if (!recsBlock) {
            const sidebar = document.querySelector('.dashboard__sidebar');
            if (sidebar) {
                recsBlock = document.createElement('div');
                recsBlock.id = 'recommendations';
                recsBlock.className = 'recommendations';
                sidebar.appendChild(recsBlock);
            }
        }
        
        if (recsBlock && recommendations.length > 0) {
            recsBlock.innerHTML = `
                <h3 class="recommendations__title">Рекомендации</h3>
                <ul class="recommendations__list">
                    ${recommendations.map(rec => `<li>${rec}</li>`).join('')}
                </ul>
            `;
        }
    }

    handleAlert(message) {
        console.warn('Alert received:', message);
        
        // Создаем всплывающее уведомление
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${message.severity || 'info'}`;
        alertDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            background: ${message.severity === 'high' ? '#FF5B5B' : '#FFA500'};
            color: white;
            border-radius: 8px;
            z-index: 10000;
            animation: slideIn 0.3s ease;
            max-width: 400px;
        `;
        alertDiv.innerHTML = `
            <strong>Внимание!</strong> ${message.message}
            <button onclick="this.parentElement.remove()" style="
                background: none;
                border: none;
                color: white;
                font-size: 20px;
                cursor: pointer;
                float: right;
                margin-left: 10px;
            ">×</button>
        `;
        
        document.body.appendChild(alertDiv);
        
        // Автоматически удаляем через 10 секунд
        setTimeout(() => {
            if (alertDiv.parentElement) {
                alertDiv.remove();
            }
        }, 10000);
    }

    handleSessionChange(message) {
        console.log('Session change:', message);
        
        if (message.type === 'session_ended') {
            // Очищаем данные при завершении сессии
            this.realTimeData = {
                labels: [],
                fhr: [],
                ua: [],
                timestamps: []
            };
            this.startTime = Date.now();
            this.initializeEvents();
        }
    }

    updateConnectionStatus(connected) {
        // Создаем индикатор статуса если его нет
        let statusElement = document.getElementById('connectionStatus');
        if (!statusElement) {
            statusElement = document.createElement('div');
            statusElement.id = 'connectionStatus';
            statusElement.className = 'connection-status';
            statusElement.innerHTML = `
                <span class="status-indicator"></span>
                <span class="status-text">Connecting...</span>
            `;
            const header = document.querySelector('.dashboard__header');
            if (header) {
                header.appendChild(statusElement);
            }
        }

        const indicator = statusElement.querySelector('.status-indicator');
        const text = statusElement.querySelector('.status-text');
        
        if (connected) {
            indicator.className = 'status-indicator connected';
            text.textContent = 'Real-time Data';
            text.style.color = '#2ED47A';
        } else {
            indicator.className = 'status-indicator disconnected';
            text.textContent = 'Disconnected';
            text.style.color = '#FF5B5B';
        }
    }

    // ... остальные методы остаются без изменений ...

    initializeCharts() {
        // Создаем график благополучия с начальным значением
        ChartManager.createWellbeingChart('wellbeingChart', 95);
        
        // Создаем начальные пустые графики
        const initialData = {
            labels: [0],
            fhr: [140],
            ua: [0],
            timestamps: [new Date()]
        };
        
        ChartManager.createFHRChart('fhrChart', initialData, this.windowSize);
        ChartManager.createUAChart('uaChart', initialData, this.windowSize);
    }

    initializeEvents() {
        const eventsList = document.getElementById('eventsList');
        if (eventsList) {
            eventsList.innerHTML = '';
            const placeholder = document.createElement('div');
            placeholder.className = 'events__placeholder';
            placeholder.textContent = 'События будут отображаться в реальном времени...';
            eventsList.appendChild(placeholder);
        }
    }

    // ... все остальные методы остаются без изменений ...
    
    initializeScrubber() {
        this.scrubber = document.getElementById('scrubber');
        this.scrubberHandle = document.getElementById('scrubberHandle');
        this.scrubberTrack = this.scrubber?.querySelector('.ktg__scrubber-track');
        
        if (this.scrubber && this.scrubberHandle) {
            this.setupScrubberInteractions();
        }
    }

    setupScrubberInteractions() {
        if (!this.scrubberHandle) return;
        
        this.scrubberHandle.addEventListener('mousedown', this.handleMouseDown.bind(this));
        document.addEventListener('mousemove', this.handleMouseMove.bind(this));
        document.addEventListener('mouseup', this.handleMouseUp.bind(this));
        
        this.scrubberHandle.addEventListener('touchstart', this.handleTouchStart.bind(this));
        document.addEventListener('touchmove', this.handleTouchMove.bind(this));
        document.addEventListener('touchend', this.handleTouchEnd.bind(this));
        
        if (this.scrubberTrack) {
            this.scrubberTrack.addEventListener('click', (e) => {
                if (this.isRealTimeMode) {
                    this.handleTrackClick(e);
                }
            });
        }
    }

    // ... все остальные методы остаются такими же ...
    
    handleMouseDown(e) {
        e.preventDefault();
        this.isDragging = true;
        this.scrubberHandle.style.cursor = 'grabbing';
        this.wasAutoScrolling = this.isAutoScrolling;
        this.isAutoScrolling = false;
    }

    handleMouseMove(e) {
        if (!this.isDragging) return;
        this.updatePositionFromEvent(e.clientX);
    }

    handleMouseUp() {
        this.isDragging = false;
        this.scrubberHandle.style.cursor = 'grab';
        if (this.isRealTimeMode) {
            const currentTime = (Date.now() - this.startTime) / 60000;
            const isAtEnd = this.currentPosition >= currentTime - 1;
            this.isAutoScrolling = isAtEnd;
        }
    }

    handleTouchStart(e) {
        e.preventDefault();
        this.isDragging = true;
        this.wasAutoScrolling = this.isAutoScrolling;
        this.isAutoScrolling = false;
    }

    handleTouchMove(e) {
        if (!this.isDragging) return;
        const touch = e.touches[0];
        this.updatePositionFromEvent(touch.clientX);
    }

    handleTouchEnd() {
        this.isDragging = false;
        if (this.isRealTimeMode) {
            const currentTime = (Date.now() - this.startTime) / 60000;
            const isAtEnd = this.currentPosition >= currentTime - 1;
            this.isAutoScrolling = isAtEnd;
        }
    }

    handleTrackClick(e) {
        const rect = this.scrubber.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const percentage = Math.max(0, Math.min(1, x / rect.width));
        
        this.currentPosition = percentage * this.totalDuration;
        this.isAutoScrolling = false;
        this.updateView();
    }

    updatePositionFromEvent(clientX) {
        const rect = this.scrubber.getBoundingClientRect();
        const x = clientX - rect.left;
        const percentage = Math.max(0, Math.min(1, x / rect.width));
        
        this.currentPosition = percentage * this.totalDuration;
        this.updateView();
    }

    updateView() {
        const displayData = this.getDisplayData();
        this.updateChartsWithScroll(displayData);
        this.updateScrubberPosition();
        this.updateTimeDisplays();
        this.handleAutoScroll();
    }

    getDisplayData() {
        const totalPoints = this.realTimeData.labels.length;
        if (totalPoints === 0) {
            return { 
                labels: [0], 
                fhr: [140], 
                ua: [0], 
                timestamps: [new Date()] 
            };
        }

        const windowStart = this.currentPosition;
        const windowEnd = windowStart + this.windowSize;
        
        let startIndex = 0;
        let endIndex = totalPoints - 1;
        
        for (let i = 0; i < totalPoints; i++) {
            if (this.realTimeData.labels[i] >= windowStart) {
                startIndex = i;
                break;
            }
        }
        
        for (let i = totalPoints - 1; i >= 0; i--) {
            if (this.realTimeData.labels[i] <= windowEnd) {
                endIndex = i;
                break;
            }
        }
        
        if (startIndex > endIndex) {
            startIndex = Math.max(0, endIndex - 10);
        }
        
        return {
            labels: this.realTimeData.labels.slice(startIndex, endIndex + 1),
            fhr: this.realTimeData.fhr.slice(startIndex, endIndex + 1),
            ua: this.realTimeData.ua.slice(startIndex, endIndex + 1),
            timestamps: this.realTimeData.timestamps.slice(startIndex, endIndex + 1)
        };
    }

    updateChartsWithScroll(data) {
        if (!data.labels.length) return;

        const displayMinTime = this.currentPosition;
        const displayMaxTime = this.currentPosition + this.windowSize;

        if (ChartManager.charts.fhr) {
            ChartManager.charts.fhr.data.labels = data.labels;
            ChartManager.charts.fhr.data.datasets[0].data = data.fhr;
            ChartManager.charts.fhr.options.scales.x.min = displayMinTime;
            ChartManager.charts.fhr.options.scales.x.max = displayMaxTime;
            ChartManager.charts.fhr.update('none');
        }

        if (ChartManager.charts.ua) {
            ChartManager.charts.ua.data.labels = data.labels;
            ChartManager.charts.ua.data.datasets[0].data = data.ua;
            ChartManager.charts.ua.options.scales.x.min = displayMinTime;
            ChartManager.charts.ua.options.scales.x.max = displayMaxTime;
            ChartManager.charts.ua.update('none');
        }
    }

    handleAutoScroll() {
        if (!this.isRealTimeMode) return;
        
        const currentTime = (Date.now() - this.startTime) / 60000;
        const isAtEnd = this.currentPosition >= currentTime - 1;
        
        if (isAtEnd && !this.isDragging) {
            this.currentPosition = Math.max(0, currentTime - this.windowSize + 1);
            this.isAutoScrolling = true;
        }
    }

    updateScrubberPosition() {
        if (!this.scrubberHandle) return;
        
        const currentTime = (Date.now() - this.startTime) / 60000;
        const maxPosition = Math.max(this.totalDuration, currentTime);
        const percentage = Math.min(1, this.currentPosition / maxPosition);
        
        this.scrubberHandle.style.left = `${percentage * 100}%`;
    }

    updateTimeDisplays() {
        const startTimeEl = document.getElementById('startTime');
        const endTimeEl = document.getElementById('endTime');
        const currentTimeEl = document.getElementById('currentTime');
        
        if (!startTimeEl || !endTimeEl || !currentTimeEl) return;
        
        const windowStart = this.currentPosition;
        const windowEnd = this.currentPosition + this.windowSize;
        const currentTime = (Date.now() - this.startTime) / 60000;
        
        startTimeEl.textContent = this.formatTime(windowStart);
        endTimeEl.textContent = this.formatTime(windowEnd);
        currentTimeEl.textContent = this.formatTime(currentTime);
        
        const modeIndicator = document.querySelector('.time-display__mode');
        if (modeIndicator) {
            if (this.isAutoScrolling && !this.isDragging) {
                modeIndicator.textContent = 'LIVE';
                modeIndicator.style.color = '#2ED47A';
            } else {
                modeIndicator.textContent = 'MANUAL';
                modeIndicator.style.color = '#FF5B5B';
            }
        }
    }

    formatTime(minutes) {
        const totalSeconds = Math.floor(minutes * 60);
        const hrs = Math.floor(totalSeconds / 3600);
        const mins = Math.floor((totalSeconds % 3600) / 60);
        const secs = totalSeconds % 60;
        
        if (hrs > 0) {
            return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    startAutoUpdate() {
        this.autoUpdateInterval = setInterval(() => {
            this.updateView();
        }, 500);
    }

    stopAutoUpdate() {
        if (this.autoUpdateInterval) {
            clearInterval(this.autoUpdateInterval);
            this.autoUpdateInterval = null;
        }
    }

    navigateToEvent(event, index) {
        if (this.isRealTimeMode) {
            console.log('Event navigation disabled in real-time mode');
            return;
        }
        
        const eventCenter = (event.startMinute + event.endMinute) / 2;
        this.currentPosition = eventCenter;
        
        const allEvents = document.querySelectorAll('.events__item');
        allEvents.forEach(item => item.classList.remove('events__item--active'));
        if (allEvents[index]) {
            allEvents[index].classList.add('events__item--active');
        }
        
        this.activeEventIndex = index;
        this.updateView();
    }

    startAutoPlay() {
        if (this.isRealTimeMode) return;
        this.stopAutoPlay();
        this.autoPlayInterval = setInterval(() => {
            this.currentPosition += 0.5;
            if (this.currentPosition >= 180) {
                this.currentPosition = 0;
            }
            this.updateView();
        }, 100);
    }

    stopAutoPlay() {
        if (this.autoPlayInterval) {
            clearInterval(this.autoPlayInterval);
            this.autoPlayInterval = null;
        }
    }

    print() {
        window.print();
    }

    destroy() {
        this.stopAutoUpdate();
        this.stopAutoPlay();
        if (this.socket) {
            this.socket.close();
        }
    }
}

// Initialize dashboard when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.dashboard = new KTGDashboard();
    
    // Add keyboard controls
    document.addEventListener('keydown', (e) => {
        if (window.dashboard.isRealTimeMode) {
            switch(e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    window.dashboard.currentPosition = Math.max(0, window.dashboard.currentPosition - 5);
                    window.dashboard.isAutoScrolling = false;
                    window.dashboard.updateView();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    const currentTime = (Date.now() - window.dashboard.startTime) / 60000;
                    window.dashboard.currentPosition = Math.min(
                        window.dashboard.totalDuration, 
                        window.dashboard.currentPosition + 5
                    );
                    if (window.dashboard.currentPosition >= currentTime - 1) {
                        window.dashboard.isAutoScrolling = true;
                    }
                    window.dashboard.updateView();
                    break;
                case 'Home':
                    e.preventDefault();
                    window.dashboard.currentPosition = 0;
                    window.dashboard.isAutoScrolling = false;
                    window.dashboard.updateView();
                    break;
                case 'End':
                    e.preventDefault();
                    const now = (Date.now() - window.dashboard.startTime) / 60000;
                    window.dashboard.currentPosition = Math.max(0, now - window.dashboard.windowSize + 1);
                    window.dashboard.isAutoScrolling = true;
                    window.dashboard.updateView();
                    break;
            }
            return;
        }
        
        switch(e.key) {
            case 'ArrowLeft':
                e.preventDefault();
                window.dashboard.currentPosition = Math.max(0, window.dashboard.currentPosition - 1);
                window.dashboard.updateView();
                break;
            case 'ArrowRight':
                e.preventDefault();
                window.dashboard.currentPosition = Math.min(180, window.dashboard.currentPosition + 1);
                window.dashboard.updateView();
                break;
            case ' ':
                e.preventDefault();
                if (window.dashboard.autoPlayInterval) {
                    window.dashboard.stopAutoPlay();
                } else {
                    window.dashboard.startAutoPlay();
                }
                break;
            case 'p':
            case 'P':
                e.preventDefault();
                window.dashboard.print();
                break;
        }
    });
    
    // Print button functionality
    const printBtn = document.querySelector('.ktg__print-btn');
    if (printBtn) {
        printBtn.addEventListener('click', () => {
            window.dashboard.print();
        });
    }
});


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\guardian_angel_front\js\charts.js
================================================================================

/**
 * Chart creation and management functions
 * Separate FHR and UA charts for traditional CTG display
 */

const ChartManager = {
    charts: {},

    /**
     * Create wellbeing donut chart
     */
    createWellbeingChart(canvasId, value) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        
        if (this.charts.wellbeing) {
            this.charts.wellbeing.destroy();
        }

        this.charts.wellbeing = new Chart(ctx, {
            type: 'doughnut',
            data: {
                datasets: [{
                    data: [value, 100 - value],
                    backgroundColor: ['#2ED47A', '#F0F0F3'],
                    borderWidth: 0,
                    borderRadius: 10,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                cutout: '75%',
                plugins: {
                    legend: { display: false },
                    tooltip: { enabled: false }
                }
            },
            plugins: [{
                id: 'centerText',
                afterDraw: function(chart) {
                    const ctx = chart.ctx;
                    ctx.save();
                    
                    const centerX = (chart.chartArea.left + chart.chartArea.right) / 2;
                    const centerY = (chart.chartArea.top + chart.chartArea.bottom) / 2;
                    
                    ctx.font = '800 42px Manrope';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#2C2C3A';
                    ctx.fillText(value, centerX, centerY);
                    
                    ctx.restore();
                }
            }]
        });

        return this.charts.wellbeing;
    },

    /**
     * Create FHR (Fetal Heart Rate) chart with fixed grid
     */
    createFHRChart(canvasId, data, windowSize = 30) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        
        if (this.charts.fhr) {
            this.charts.fhr.destroy();
        }

        // ФИКСИРОВАННОЕ окно отображения
        const displayMinTime = 0;
        const displayMaxTime = windowSize;

        this.charts.fhr = new Chart(ctx, {
            type: 'line',
            data: {
                labels: data.labels,
                datasets: [{
                    label: 'ЧСС',
                    data: data.fhr,
                    borderColor: '#FF1744', // Red for FHR
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 2, // УВЕЛИЧЕН размер точек
                    pointHoverRadius: 6,
                    tension: 0.1,
                    clip: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: {
                        left: 15,
                        right: 15,
                        top: 15,
                        bottom: 0
                    }
                },
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                scales: {
                    x: {
                        type: 'linear',
                        min: displayMinTime,
                        max: displayMaxTime, // ФИКСИРОВАННОЕ окно
                        grid: {
                            color: function(context) {
                                // Major grid lines every 5 минут (УВЕЛИЧЕН ШАГ)
                                if (context.tick.value % 5 === 0) {
                                    return 'rgba(0, 0, 0, 0.15)';
                                }
                                return 'transparent';
                            },
                            lineWidth: function(context) {
                                if (context.tick.value % 5 === 0) {
                                    return 1.5;
                                }
                                return 0;
                            },
                            drawTicks: false
                        },
                        border: {
                            display: false
                        },
                        ticks: {
                            display: false,
                            stepSize: 5, // УВЕЛИЧЕН шаг
                            callback: function(value) {
                                return value + ' мин';
                            }
                        }
                    },
                    y: {
                        min: 50,
                        max: 210,
                        position: 'right',
                        grid: {
                            color: function(context) {
                                // Major grid lines every 30 units (УВЕЛИЧЕН ШАГ)
                                if (context.tick.value % 30 === 0) {
                                    return 'rgba(0, 0, 0, 0.15)';
                                }
                                return 'transparent';
                            },
                            lineWidth: function(context) {
                                if (context.tick.value % 30 === 0) {
                                    return 1.5;
                                }
                                return 0;
                            }
                        },
                        border: {
                            display: false
                        },
                        ticks: {
                            stepSize: 10,
                            font: {
                                family: 'Manrope',
                                size: 12,
                                weight: '700'
                            },
                            color: '#555',
                            padding: 8,
                            callback: function(value) {
                                // Show only major tick labels (30 units)
                                if (value % 30 === 0) {
                                    return value;
                                }
                                return '';
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: true,
                        backgroundColor: 'rgba(255, 255, 255, 0.98)',
                        titleColor: '#333',
                        bodyColor: '#666',
                        borderColor: '#ddd',
                        borderWidth: 1.5,
                        padding: 12,
                        displayColors: false,
                        titleFont: {
                            size: 13,
                            weight: '600'
                        },
                        bodyFont: {
                            size: 12,
                            weight: '600'
                        },
                        callbacks: {
                            title: function(context) {
                                const minutes = context[0].parsed.x;
                                const totalSeconds = Math.floor(minutes * 60);
                                const hrs = Math.floor(totalSeconds / 3600);
                                const mins = Math.floor((totalSeconds % 3600) / 60);
                                const secs = totalSeconds % 60;
                                
                                if (hrs > 0) {
                                    return `Время: ${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                                }
                                return `Время: ${mins}:${secs.toString().padStart(2, '0')}`;
                            },
                            label: function(context) {
                                return 'ЧСС: ' + Math.round(context.parsed.y) + ' уд/мин';
                            }
                        }
                    },
                    annotation: {
                        annotations: {
                            // Lower normal boundary
                            lowerNormal: {
                                type: 'line',
                                yMin: 110,
                                yMax: 110,
                                borderColor: 'rgba(255, 0, 0, 0.4)',
                                borderWidth: 1.2,
                                borderDash: [5, 5]
                            },
                            // Upper normal boundary
                            upperNormal: {
                                type: 'line',
                                yMin: 170,
                                yMax: 170,
                                borderColor: 'rgba(255, 0, 0, 0.4)',
                                borderWidth: 1.2,
                                borderDash: [5, 5]
                            },
                            // Normal range zone
                            normalZone: {
                                type: 'box',
                                yMin: 110,
                                yMax: 170,
                                backgroundColor: 'rgba(0, 255, 0, 0.03)',
                                borderWidth: 0
                            }
                        }
                    }
                }
            }
        });

        return this.charts.fhr;
    },

    /**
     * Create UA (Uterine Activity) chart with fixed grid - now labeled as СДМ
     */
    createUAChart(canvasId, data, windowSize = 30) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        
        if (this.charts.ua) {
            this.charts.ua.destroy();
        }

        // ФИКСИРОВАННОЕ окно отображения
        const displayMinTime = 0;
        const displayMaxTime = windowSize;

        this.charts.ua = new Chart(ctx, {
            type: 'line',
            data: {
                labels: data.labels,
                datasets: [{
                    label: 'СДМ',
                    data: data.ua,
                    borderColor: '#0D47A1', // Dark blue for UA
                    backgroundColor: 'rgba(13, 71, 161, 0.08)',
                    borderWidth: 2,
                    pointRadius: 2, // УВЕЛИЧЕН размер точек
                    pointHoverRadius: 6,
                    tension: 0.1,
                    fill: true,
                    clip: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: {
                        left: 15,
                        right: 15,
                        top: 0,
                        bottom: 15
                    }
                },
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                scales: {
                    x: {
                        type: 'linear',
                        min: displayMinTime,
                        max: displayMaxTime, // ФИКСИРОВАННОЕ окно
                        grid: {
                            color: function(context) {
                                // Major grid lines every 5 минут (УВЕЛИЧЕН ШАГ)
                                if (context.tick.value % 5 === 0) {
                                    return 'rgba(0, 0, 0, 0.15)';
                                }
                                return 'transparent';
                            },
                            lineWidth: function(context) {
                                if (context.tick.value % 5 === 0) {
                                    return 1.5;
                                }
                                return 0;
                            },
                            drawTicks: true
                        },
                        border: {
                            display: false
                        },
                        ticks: {
                            stepSize: 5,
                            font: {
                                family: 'Manrope',
                                size: 12,
                                weight: '700'
                            },
                            color: '#555',
                            padding: 10,
                            callback: function(value) {
                                if (value % 5 === 0) { // Каждые 5 минут
                                    return value + ' мин';
                                }
                                return '';
                            }
                        }
                    },
                    y: {
                        min: 0,
                        max: 100,
                        position: 'right',
                        grid: {
                            color: function(context) {
                                // Major grid lines every 25 units (УВЕЛИЧЕН ШАГ)
                                if (context.tick.value % 25 === 0) {
                                    return 'rgba(0, 0, 0, 0.15)';
                                }
                                return 'transparent';
                            },
                            lineWidth: function(context) {
                                if (context.tick.value % 25 === 0) {
                                    return 1.5;
                                }
                                return 0;
                            }
                        },
                        border: {
                            display: false
                        },
                        ticks: {
                            stepSize: 10,
                            font: {
                                family: 'Manrope',
                                size: 12,
                                weight: '700'
                            },
                            color: '#555',
                            padding: 8,
                            callback: function(value) {
                                // Show only major tick labels (25 units)
                                if (value % 25 === 0) {
                                    return value;
                                }
                                return '';
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: true,
                        backgroundColor: 'rgba(255, 255, 255, 0.98)',
                        titleColor: '#333',
                        bodyColor: '#666',
                        borderColor: '#ddd',
                        borderWidth: 1.5,
                        padding: 12,
                        displayColors: false,
                        titleFont: {
                            size: 13,
                            weight: '600'
                        },
                        bodyFont: {
                            size: 12,
                            weight: '600'
                        },
                        callbacks: {
                            title: function(context) {
                                const minutes = context[0].parsed.x;
                                const totalSeconds = Math.floor(minutes * 60);
                                const hrs = Math.floor(totalSeconds / 3600);
                                const mins = Math.floor((totalSeconds % 3600) / 60);
                                const secs = totalSeconds % 60;
                                
                                if (hrs > 0) {
                                    return `Время: ${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                                }
                                return `Время: ${mins}:${secs.toString().padStart(2, '0')}`;
                            },
                            label: function(context) {
                                return 'СДМ: ' + Math.round(context.parsed.y) + ' отн.ед';
                            }
                        }
                    },
                    annotation: {
                        annotations: {
                            // No baseline for UA chart
                        }
                    }
                }
            }
        });

        return this.charts.ua;
    },

    /**
     * Update both FHR and UA charts with new data and fixed grid
     */
    updateChartsWithFixedGrid(data, currentPosition, windowSize = 30) {
        // ФИКСИРОВАННОЕ окно отображения
        const displayMinTime = currentPosition;
        const displayMaxTime = currentPosition + windowSize;

        // Update FHR chart
        if (this.charts.fhr) {
            this.charts.fhr.data.labels = data.labels;
            this.charts.fhr.data.datasets[0].data = data.fhr;
            this.charts.fhr.options.scales.x.min = displayMinTime;
            this.charts.fhr.options.scales.x.max = displayMaxTime;
            this.charts.fhr.update('none');
        }

        // Update UA chart
        if (this.charts.ua) {
            this.charts.ua.data.labels = data.labels;
            this.charts.ua.data.datasets[0].data = data.ua;
            this.charts.ua.options.scales.x.min = displayMinTime;
            this.charts.ua.options.scales.x.max = displayMaxTime;
            this.charts.ua.update('none');
        }
    },

    /**
     * Update chart data only (for real-time streaming)
     */
    updateChartData(data) {
        // Update FHR chart data only
        if (this.charts.fhr) {
            this.charts.fhr.data.labels = data.labels;
            this.charts.fhr.data.datasets[0].data = data.fhr;
        }

        // Update UA chart data only
        if (this.charts.ua) {
            this.charts.ua.data.labels = data.labels;
            this.charts.ua.data.datasets[0].data = data.ua;
        }
    },

    /**
     * Update chart viewport (for scrolling)
     */
    updateChartViewport(currentPosition, windowSize = 30) {
        const displayMinTime = currentPosition;
        const displayMaxTime = currentPosition + windowSize;

        // Update FHR chart viewport
        if (this.charts.fhr) {
            this.charts.fhr.options.scales.x.min = displayMinTime;
            this.charts.fhr.options.scales.x.max = displayMaxTime;
        }

        // Update UA chart viewport
        if (this.charts.ua) {
            this.charts.ua.options.scales.x.min = displayMinTime;
            this.charts.ua.options.scales.x.max = displayMaxTime;
        }
    },

    /**
     * Update both charts completely
     */
    updateCharts(data, currentPosition, windowSize = 30) {
        this.updateChartData(data);
        this.updateChartViewport(currentPosition, windowSize);
        
        // Update both charts
        if (this.charts.fhr) {
            this.charts.fhr.update('none');
        }
        if (this.charts.ua) {
            this.charts.ua.update('none');
        }
    }
};

// Export for use in other modules
window.ChartManager = ChartManager;


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\guardian_angel_front\js\data.js
================================================================================

/**
 * Mock Data Generator for KTG Dashboard
 */

const MockData = {
    // Patient information
    patient: {
        name: 'Милюкова Мария Ивановна',
        weeks: 28,
        wellbeingIndex: 95
    },

    // Events data with start and end minutes
    events: [
        { 
            name: 'АКЦЕЛЕРАЦИЯ', 
            startMinute: 5, 
            endMinute: 5.5,
            displayTime: '5 - 5.5'
        },
        { 
            name: 'СХВАТКА', 
            startMinute: 8.33, 
            endMinute: 10,
            displayTime: '8 - 10'
        },
        { 
            name: 'АКЦЕЛЕРАЦИЯ', 
            startMinute: 10, 
            endMinute: 10.5,
            displayTime: '10 - 10.5'
        },
        { 
            name: 'СХВАТКА', 
            startMinute: 20, 
            endMinute: 22,
            displayTime: '20 - 22'
        },
        { 
            name: 'АКЦЕЛЕРАЦИЯ', 
            startMinute: 30, 
            endMinute: 30.5,
            displayTime: '30 - 30.5'
        },
        { 
            name: 'СХВАТКА', 
            startMinute: 33.33, 
            endMinute: 35.5,
            displayTime: '33 - 35'
        },
        { 
            name: 'ДЕЦЕЛЕРАЦИЯ', 
            startMinute: 45, 
            endMinute: 46,
            displayTime: '45 - 46'
        },
        { 
            name: 'СХВАТКА', 
            startMinute: 50, 
            endMinute: 52,
            displayTime: '50 - 52'
        },
        { 
            name: 'АКЦЕЛЕРАЦИЯ', 
            startMinute: 60, 
            endMinute: 60.5,
            displayTime: '60 - 60.5'
        }
    ],

    // Generate 3 hours of CTG data
    generateCTGData() {
        const duration = 180; // 3 hours in minutes
        const pointsPerMinute = 10; // 10 points per minute for smooth curves
        const totalPoints = duration * pointsPerMinute;
        
        const data = {
            labels: [],
            fhr: [], // Fetal Heart Rate (ЧСС)
            ua: [],  // Uterine Activity (СДМ)
            timestamps: []
        };

        // Generate timestamps
        const startTime = new Date('2024-01-01T14:00:00');
        
        // FHR baseline and variability
        const fhrBaseline = 135;
        
        for (let i = 0; i < totalPoints; i++) {
            const minutes = i / pointsPerMinute;
            data.labels.push(minutes);
            
            const currentTime = new Date(startTime.getTime() + minutes * 60000);
            data.timestamps.push(currentTime);

            // Generate FHR with normal variability
            let fhrDelta = this.normalRandom(0, 5); // Base variability
            
            // Add accelerations based on events
            for (const event of this.events) {
                if (event.name === 'АКЦЕЛЕРАЦИЯ') {
                    if (minutes >= event.startMinute && minutes < event.endMinute) {
                        const t = (minutes - event.startMinute) / (event.endMinute - event.startMinute);
                        fhrDelta += 20 * Math.sin(t * Math.PI);
                    }
                } else if (event.name === 'ДЕЦЕЛЕРАЦИЯ') {
                    if (minutes >= event.startMinute && minutes < event.endMinute) {
                        const t = (minutes - event.startMinute) / (event.endMinute - event.startMinute);
                        fhrDelta -= 25 * Math.sin(t * Math.PI);
                    }
                }
            }
            
            // Apply FHR value
            let fhrValue = fhrBaseline + fhrDelta;
            
            // Add some sinusoidal variation for realism
            fhrValue += 3 * Math.sin(i * 0.02) + 2 * Math.cos(i * 0.03);
            
            // Clip to reasonable range
            data.fhr.push(Math.max(100, Math.min(180, fhrValue)));

            // Generate Uterine Activity (contractions)
            let uaValue = 0;
            
            // Generate contractions based on events
            for (const event of this.events) {
                if (event.name === 'СХВАТКА') {
                    if (minutes >= event.startMinute && minutes <= event.endMinute) {
                        const t = (minutes - event.startMinute) / (event.endMinute - event.startMinute);
                        uaValue = Math.sin(t * Math.PI) * 80 + 10;
                    }
                }
            }
            
            // Add minimal baseline activity
            if (uaValue === 0) {
                uaValue = Math.max(0, 5 + this.normalRandom(0, 2));
            }
            
            data.ua.push(Math.max(0, Math.min(100, uaValue)));
        }

        return data;
    },

    // Normal distribution random number generator
    normalRandom(mean, stdDev) {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        const num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        return num * stdDev + mean;
    },

    // Get a window of data (30 minutes by default)
    getDataWindow(fullData, centerMinute, windowSize = 30) {
        const pointsPerMinute = 10;
        const startMinute = Math.max(0, centerMinute - windowSize / 2);
        const endMinute = Math.min(180, startMinute + windowSize);
        
        const startIndex = Math.floor(startMinute * pointsPerMinute);
        const endIndex = Math.floor(endMinute * pointsPerMinute);
        
        return {
            labels: fullData.labels.slice(startIndex, endIndex),
            fhr: fullData.fhr.slice(startIndex, endIndex),
            ua: fullData.ua.slice(startIndex, endIndex),
            timestamps: fullData.timestamps.slice(startIndex, endIndex),
            startMinute,
            endMinute
        };
    },

    // Format time for display
    formatTime(minutes) {
        const hours = Math.floor(minutes / 60);
        const mins = Math.floor(minutes % 60);
        const baseHour = 14; // Starting at 14:00
        const displayHour = baseHour + hours;
        return `${displayHour.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
    }
};

// Export for use in other modules
window.MockData = MockData;


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\guardian_angel_front\js\history.js
================================================================================

/**
 * History page with CTG data from backend API
 */

// Хранилище для графиков и их контроллеров
const historyCharts = {};
const scrubberControllers = {};

// Базовый URL для API
const API_BASE_URL = 'http://localhost:8000';

// Главная функция для загрузки и отображения истории
async function fetchAndRenderHistory() {
    const container = document.getElementById('historySessions');
    
    if (!container) return;
    
    // Показываем индикатор загрузки
    container.innerHTML = `
        <div class="loading-message">
            <div class="spinner"></div>
            <p>Загрузка истории записей...</p>
        </div>
    `;
    
    try {
        // Запрашиваем список сессий
        const sessionsResponse = await fetch(`${API_BASE_URL}/history/sessions`);
        const sessions = await sessionsResponse.json();
        
        // Проверяем, есть ли записи
        if (!sessions || sessions.length === 0) {
            container.innerHTML = `
                <div class="no-records">
                    <p>Нет записей</p>
                </div>
            `;
            return;
        }
        
        // Загружаем детальные данные для каждой сессии
        const sessionsWithData = [];
        
        for (const session of sessions) {
            try {
                // Запрашиваем данные графика для сессии
                const dataResponse = await fetch(`${API_BASE_URL}/history/session/${session.id}`);
                const graphData = await dataResponse.json();
                
                // Объединяем информацию о сессии с данными для графика
                sessionsWithData.push({
                    ...session,
                    data: graphData.data
                });
            } catch (error) {
                console.error(`Ошибка загрузки данных для сессии ${session.id}:`, error);
            }
        }
        
        // Рендерим все загруженные сессии
        renderSessions(sessionsWithData);
        
    } catch (error) {
        console.error('Ошибка загрузки истории:', error);
        container.innerHTML = `
            <div class="error-message">
                <p>Ошибка загрузки данных</p>
                <p class="error-details">${error.message}</p>
                <button onclick="fetchAndRenderHistory()" class="retry-button">Повторить</button>
            </div>
        `;
    }
}

// Рендеринг сессий
function renderSessions(sessionsToRender) {
    const container = document.getElementById('historySessions');
    
    if (!container) return;
    
    // Очищаем предыдущие графики
    Object.keys(historyCharts).forEach(key => {
        if (key.includes('timeLabels')) {
            delete historyCharts[key];
        } else if (historyCharts[key]) {
            historyCharts[key].destroy();
            delete historyCharts[key];
        }
    });
    
    // Очищаем контроллеры скрабберов
    Object.keys(scrubberControllers).forEach(key => {
        delete scrubberControllers[key];
    });
    
    if (sessionsToRender.length === 0) {
        container.innerHTML = `
            <div class="no-records">
                <p>Нет записей для отображения</p>
            </div>
        `;
        return;
    }
    
    // Создаем HTML для всех сессий
    const sessionsHTML = sessionsToRender.map((session, index) => 
        createSessionElement(session, index)
    ).join('');
    
    container.innerHTML = sessionsHTML;
    
    // Создаем графики и скрабберы для каждой сессии
    setTimeout(() => {
        sessionsToRender.forEach((session, index) => {
            if (session.data && session.data.labels) {
                createHistoryCharts(session, index);
                scrubberControllers[index] = new HistoryScrubber(
                    index, 
                    session.data, 
                    session.durationMins,
                    session.startTime
                );
            }
        });
    }, 100);
}

// Форматирование даты
function formatDate(dateString) {
    const date = new Date(dateString);
    const months = [
        'января', 'февраля', 'марта', 'апреля', 'мая', 'июня',
        'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря'
    ];
    
    return `${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
}

// Получение статуса благополучия
function getWellbeingStatus(value) {
    if (value >= 85) return { color: '#2ED47A', text: 'Отлично' };
    if (value >= 70) return { color: '#FFC107', text: 'Норма' };
    if (value >= 50) return { color: '#FFB946', text: 'Внимание' };
    return { color: '#FF5B5B', text: 'Критично' };
}

// Генерация меток времени
function generateTimeLabels(startTime, durationMins) {
    const labels = [];
    const [hours, minutes] = startTime.split(':').map(Number);
    const startMinutes = hours * 60 + minutes;
    
    for (let i = 0; i <= durationMins; i++) {
        const totalMinutes = startMinutes + i;
        const h = Math.floor(totalMinutes / 60) % 24;
        const m = totalMinutes % 60;
        labels.push(`${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`);
    }
    
    return labels;
}

// Создание HTML для сессии
function createSessionElement(session, index) {
    const wellbeingStatus = getWellbeingStatus(session.avgFwbs);
    const formattedDate = formatDate(session.date);
    
    return `
        <div class="history-session-block" data-id="${session.id}" data-date="${session.date}">
            <!-- Шапка блока -->
            <div class="history-session-header">
                <div class="history-session-info">
                    <h3 class="history-session-date">${formattedDate}</h3>
                    <div class="history-session-time">
                        <span>Время записи: ${session.startTime} - ${session.endTime}</span>
                        <span class="history-session-separator">•</span>
                        <span>Длительность: ${session.durationMins} мин</span>
                    </div>
                </div>
                <div class="history-session-badges">
                    <div class="session-badge session-badge--fischer">
                        <span class="session-badge-label">Фишер</span>
                        <span class="session-badge-value">${session.fischerScore}/10</span>
                    </div>
                    <div class="session-badge session-badge--wellbeing" style="--wb-color: ${wellbeingStatus.color}">
                        <span class="session-badge-label">Индекс</span>
                        <span class="session-badge-value">${session.avgFwbs}</span>
                        <span class="session-badge-status">${wellbeingStatus.text}</span>
                    </div>
                </div>
            </div>
            
            <!-- График КТГ -->
            <section class="history-ktg card">
                <div class="ktg">
                    <!-- FHR Chart (Top) -->
                    <div class="ktg__chart-group">
                        <div class="ktg__chart-label">
                            <span class="ktg__chart-title">ЧСС</span>
                            <span class="ktg__chart-units">уд/мин</span>
                        </div>
                        <div class="ktg__chart-container ktg__chart-container--fhr">
                            <canvas id="history-fhr-${index}"></canvas>
                        </div>
                    </div>
                    
                    <!-- UA Chart (Bottom) -->
                    <div class="ktg__chart-group">
                        <div class="ktg__chart-label">
                            <span class="ktg__chart-title">СДМ</span>
                            <span class="ktg__chart-units">отн.ед</span>
                        </div>
                        <div class="ktg__chart-container ktg__chart-container--ua">
                            <canvas id="history-ua-${index}"></canvas>
                        </div>
                    </div>
                    
                    <!-- Timeline Controls -->
                    <div class="ktg__timeline">
                        <div class="ktg__time-start">
                            <span>НАЧАЛО</span>
                            <span id="startTime-${index}">${session.startTime}</span>
                        </div>
                        <div class="ktg__scrubber" id="scrubber-${index}">
                            <div class="ktg__scrubber-track"></div>
                            <div class="ktg__scrubber-handle" id="scrubberHandle-${index}">
                                <div class="ktg__scrubber-time" id="currentTime-${index}">${session.startTime.substring(0, 5)}</div>
                            </div>
                        </div>
                        <div class="ktg__time-end">
                            <span>КОНЕЦ</span>
                            <span id="endTime-${index}">${session.endTime}</span>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    `;
}

// Класс для управления скраббером
class HistoryScrubber {
    constructor(sessionIndex, sessionData, durationMins, startTime) {
        this.sessionIndex = sessionIndex;
        this.sessionData = sessionData;
        this.duration = durationMins;
        this.startTime = startTime;
        this.currentPosition = 0;
        this.windowSize = 30; // Окно в 30 минут
        this.isDragging = false;
        this.timeLabels = historyCharts[`timeLabels-${sessionIndex}`];
        
        this.initElements();
        this.initEventListeners();
        this.updateView(0);
    }
    
    initElements() {
        this.scrubber = document.getElementById(`scrubber-${this.sessionIndex}`);
        this.scrubberHandle = document.getElementById(`scrubberHandle-${this.sessionIndex}`);
        this.currentTimeEl = document.getElementById(`currentTime-${this.sessionIndex}`);
    }
    
    initEventListeners() {
        if (!this.scrubberHandle || !this.scrubber) return;
        
        this.scrubberHandle.addEventListener('mousedown', this.handleMouseDown.bind(this));
        document.addEventListener('mousemove', this.handleMouseMove.bind(this));
        document.addEventListener('mouseup', this.handleMouseUp.bind(this));
        
        this.scrubberHandle.addEventListener('touchstart', this.handleTouchStart.bind(this));
        document.addEventListener('touchmove', this.handleTouchMove.bind(this));
        document.addEventListener('touchend', this.handleTouchEnd.bind(this));
        
        this.scrubber.addEventListener('click', this.handleTrackClick.bind(this));
    }
    
    handleMouseDown(e) {
        e.preventDefault();
        this.isDragging = true;
        this.scrubberHandle.style.cursor = 'grabbing';
    }
    
    handleMouseMove(e) {
        if (!this.isDragging) return;
        this.updatePositionFromEvent(e.clientX);
    }
    
    handleMouseUp() {
        this.isDragging = false;
        if (this.scrubberHandle) {
            this.scrubberHandle.style.cursor = 'grab';
        }
    }
    
    handleTouchStart(e) {
        e.preventDefault();
        this.isDragging = true;
    }
    
    handleTouchMove(e) {
        if (!this.isDragging) return;
        const touch = e.touches[0];
        this.updatePositionFromEvent(touch.clientX);
    }
    
    handleTouchEnd() {
        this.isDragging = false;
    }
    
    handleTrackClick(e) {
        if (e.target === this.scrubberHandle || e.target.parentElement === this.scrubberHandle) return;
        this.updatePositionFromEvent(e.clientX);
    }
    
    updatePositionFromEvent(clientX) {
        const rect = this.scrubber.getBoundingClientRect();
        const x = clientX - rect.left;
        const percentage = Math.max(0, Math.min(1, x / rect.width));
        
        this.currentPosition = percentage * this.duration;
        this.updateView(this.currentPosition);
    }
    
    updateView(position) {
        const percentage = position / this.duration;
        
        // Обновляем позицию ползунка
        this.scrubberHandle.style.left = `${percentage * 100}%`;
        
        // Показываем реальное время вместо минут от начала
        const currentMinuteIndex = Math.floor(position);
        if (this.timeLabels && this.timeLabels[currentMinuteIndex]) {
            this.currentTimeEl.textContent = this.timeLabels[currentMinuteIndex];
        }
        
        // Обновляем графики
        this.updateCharts(position);
    }
    
    updateCharts(centerMinute) {
        // Определяем окно просмотра
        const halfWindow = this.windowSize / 2;
        const startMin = Math.max(0, centerMinute - halfWindow);
        const endMin = Math.min(this.duration, startMin + this.windowSize);
        
        // Получаем окно данных
        const pointsPerMinute = 10;
        const startIndex = Math.floor(startMin * pointsPerMinute);
        const endIndex = Math.ceil(endMin * pointsPerMinute);
        
        const windowLabels = this.sessionData.labels.slice(startIndex, endIndex);
        const windowFHR = this.sessionData.fhr.slice(startIndex, endIndex);
        const windowUA = this.sessionData.ua.slice(startIndex, endIndex);
        
        // Обновляем график ЧСС
        if (historyCharts[`fhr-${this.sessionIndex}`]) {
            const fhrChart = historyCharts[`fhr-${this.sessionIndex}`];
            fhrChart.data.labels = windowLabels;
            fhrChart.data.datasets[0].data = windowFHR;
            fhrChart.options.scales.x.min = startMin;
            fhrChart.options.scales.x.max = endMin;
            fhrChart.update('none');
        }
        
        // Обновляем график СДМ
        if (historyCharts[`ua-${this.sessionIndex}`]) {
            const uaChart = historyCharts[`ua-${this.sessionIndex}`];
            uaChart.data.labels = windowLabels;
            uaChart.data.datasets[0].data = windowUA;
            uaChart.options.scales.x.min = startMin;
            uaChart.options.scales.x.max = endMin;
            uaChart.update('none');
        }
    }
}

// Создание графиков для сессии
function createHistoryCharts(session, index) {
    // Генерируем метки времени для всей записи
    const timeLabels = generateTimeLabels(session.startTime, session.durationMins);
    
    // Начальное окно данных (первые 30 минут или вся запись если меньше)
    const windowSize = Math.min(30, session.durationMins);
    const endIndex = Math.min(windowSize * 10, session.data.labels.length); // 10 точек на минуту
    
    // FHR Chart с фиксированными метками времени
    const fhrCtx = document.getElementById(`history-fhr-${index}`);
    if (fhrCtx) {
        historyCharts[`fhr-${index}`] = new Chart(fhrCtx, {
            type: 'line',
            data: {
                labels: session.data.labels.slice(0, endIndex),
                datasets: [{
                    label: 'ЧСС',
                    data: session.data.fhr.slice(0, endIndex),
                    borderColor: '#FF1744',
                    backgroundColor: 'transparent',
                    borderWidth: 1.5,
                    pointRadius: 0,
                    pointHoverRadius: 3,
                    tension: 0.15,
                    clip: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: {
                        left: 10,
                        right: 10,
                        top: 10,
                        bottom: 0
                    }
                },
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                scales: {
                    x: {
                        type: 'linear',
                        min: 0,
                        max: windowSize,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)',
                            lineWidth: 1,
                            drawTicks: false
                        },
                        border: {
                            display: false
                        },
                        ticks: {
                            display: false // Скрываем метки, они будут на нижнем графике
                        }
                    },
                    y: {
                        min: 50,
                        max: 210,
                        position: 'right',
                        grid: {
                            color: function(context) {
                                if (context.tick.value % 30 === 0) {
                                    return 'rgba(0, 0, 0, 0.1)';
                                }
                                return 'rgba(0, 0, 0, 0.03)';
                            },
                            lineWidth: function(context) {
                                if (context.tick.value % 30 === 0) {
                                    return 1;
                                }
                                return 0.5;
                            }
                        },
                        border: {
                            display: false
                        },
                        ticks: {
                            stepSize: 10,
                            font: {
                                family: 'Manrope',
                                size: 10,
                                weight: '600'
                            },
                            color: '#666',
                            padding: 5,
                            callback: function(value) {
                                if (value % 30 === 0) {
                                    return value;
                                }
                                return '';
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: true,
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        titleColor: '#333',
                        bodyColor: '#666',
                        borderColor: '#ddd',
                        borderWidth: 1,
                        padding: 8,
                        displayColors: false,
                        callbacks: {
                            title: function(context) {
                                const minuteIndex = Math.floor(context[0].parsed.x);
                                if (timeLabels[minuteIndex]) {
                                    return 'Время: ' + timeLabels[minuteIndex];
                                }
                                return '';
                            },
                            label: function(context) {
                                return 'ЧСС: ' + Math.round(context.parsed.y) + ' уд/мин';
                            }
                        }
                    },
                    annotation: {
                        annotations: {
                            lowerNormal: {
                                type: 'line',
                                yMin: 110,
                                yMax: 110,
                                borderColor: 'rgba(255, 0, 0, 0.3)',
                                borderWidth: 1,
                                borderDash: [5, 5]
                            },
                            upperNormal: {
                                type: 'line',
                                yMin: 170,
                                yMax: 170,
                                borderColor: 'rgba(255, 0, 0, 0.3)',
                                borderWidth: 1,
                                borderDash: [5, 5]
                            },
                            normalZone: {
                                type: 'box',
                                yMin: 110,
                                yMax: 170,
                                backgroundColor: 'rgba(0, 255, 0, 0.02)',
                                borderWidth: 0
                            }
                        }
                    }
                },
                animation: {
                    duration: 0
                }
            }
        });
    }
    
    // UA Chart с метками времени
    const uaCtx = document.getElementById(`history-ua-${index}`);
    if (uaCtx) {
        historyCharts[`ua-${index}`] = new Chart(uaCtx, {
            type: 'line',
            data: {
                labels: session.data.labels.slice(0, endIndex),
                datasets: [{
                    label: 'СДМ',
                    data: session.data.ua.slice(0, endIndex),
                    borderColor: '#0D47A1',
                    backgroundColor: 'rgba(13, 71, 161, 0.05)',
                    borderWidth: 1.5,
                    pointRadius: 0,
                    pointHoverRadius: 3,
                    tension: 0.15,
                    fill: true,
                    clip: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: {
                        left: 10,
                        right: 10,
                        top: 0,
                        bottom: 10
                    }
                },
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                scales: {
                    x: {
                        type: 'linear',
                        min: 0,
                        max: windowSize,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)',
                            lineWidth: 1,
                            drawTicks: true
                        },
                        border: {
                            display: false
                        },
                        ticks: {
                            stepSize: 5,
                            font: {
                                family: 'Manrope',
                                size: 11,
                                weight: '600'
                            },
                            color: '#666',
                            padding: 8,
                            callback: function(value, index) {
                                // Показываем время вместо минут
                                const minuteIndex = Math.floor(value);
                                if (minuteIndex % 5 === 0 && timeLabels[minuteIndex]) {
                                    return timeLabels[minuteIndex];
                                }
                                return '';
                            }
                        }
                    },
                    y: {
                        min: 0,
                        max: 100,
                        position: 'right',
                        grid: {
                            color: function(context) {
                                if (context.tick.value % 25 === 0) {
                                    return 'rgba(0, 0, 0, 0.1)';
                                }
                                if (context.tick.value % 10 === 0) {
                                    return 'rgba(0, 0, 0, 0.03)';
                                }
                                return 'transparent';
                            },
                            lineWidth: function(context) {
                                if (context.tick.value % 25 === 0) {
                                    return 1;
                                }
                                return 0.5;
                            }
                        },
                        border: {
                            display: false
                        },
                        ticks: {
                            stepSize: 10,
                            font: {
                                family: 'Manrope',
                                size: 10,
                                weight: '600'
                            },
                            color: '#666',
                            padding: 5,
                            callback: function(value) {
                                if (value % 25 === 0) {
                                    return value;
                                }
                                return '';
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: true,
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        titleColor: '#333',
                        bodyColor: '#666',
                        borderColor: '#ddd',
                        borderWidth: 1,
                        padding: 8,
                        displayColors: false,
                        callbacks: {
                            title: function(context) {
                                const minuteIndex = Math.floor(context[0].parsed.x);
                                if (timeLabels[minuteIndex]) {
                                    return 'Время: ' + timeLabels[minuteIndex];
                                }
                                return '';
                            },
                            label: function(context) {
                                return 'СДМ: ' + Math.round(context.parsed.y) + ' отн.ед';
                            }
                        }
                    }
                },
                animation: {
                    duration: 0
                }
            }
        });
    }
    
    // Сохраняем метки времени для использования в скраббере
    historyCharts[`timeLabels-${index}`] = timeLabels;
}

// Добавляем стили для индикатора загрузки и ошибок
const style = document.createElement('style');
style.textContent = `
    .loading-message, .error-message, .no-records {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 60px 20px;
        text-align: center;
        color: #666;
        font-family: 'Manrope', sans-serif;
    }
    
    .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #007BFF;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .error-details {
        font-size: 12px;
        color: #999;
        margin-top: 10px;
    }
    
    .retry-button {
        margin-top: 20px;
        padding: 10px 20px;
        background: #007BFF;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-family: 'Manrope', sans-serif;
        font-weight: 600;
        transition: background 0.3s;
    }
    
    .retry-button:hover {
        background: #0056b3;
    }
`;
document.head.appendChild(style);

// Запуск при загрузке страницы
document.addEventListener('DOMContentLoaded', fetchAndRenderHistory);


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\guardian_angel_front\css\style.css
================================================================================

/* ========================================
   VARIABLES & RESET
   ======================================== */
:root {
    --color-bg: #F4F7FE;
    --color-card: #FFFFFF;
    --color-primary: #6D63FF;
    --color-primary-light: #E8E6FF;
    --color-primary-dark: #5B51E5;
    --color-blue: #5A81FA;
    --color-blue-dark: #4A71EA;
    --color-success: #2ED47A;
    --color-danger: #FF5B5B;
    --color-warning: #FFB946;
    --color-text-dark: #2C2C3A;
    --color-text-medium: #6C6C7D;
    --color-text-light: #9A9AAB;
    --color-border: #F0F0F3;
    --color-bg-secondary: #F7F7FA;
    
    --radius-sm: 8px;
    --radius-md: 14px;
    --radius-lg: 20px;
    
    --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.04);
    --shadow-md: 0 4px 20px rgba(0, 0, 0, 0.06);
    --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.08);
    
    --font-family: 'Manrope', -apple-system, BlinkMacSystemFont, sans-serif;
    
    --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: var(--font-family);
    font-size: 16px;
    line-height: 1.5;
    color: var(--color-text-dark);
    background-color: var(--color-bg);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

/* ========================================
   LAYOUT
   ======================================== */
.dashboard {
    max-width: 1440px;
    margin: 0 auto;
    padding: 24px;
    display: grid;
    grid-template-columns: 1fr 2fr;
    grid-template-areas:
        "header header"
        "wellbeing events"
        "ktg ktg";
    gap: 24px;
}

.dashboard__header {
    grid-area: header;
}

.dashboard__wellbeing {
    grid-area: wellbeing;
}

.dashboard__events {
    grid-area: events;
}

.dashboard__ktg {
    grid-area: ktg;
}

/* ========================================
   CARD COMPONENT
   ======================================== */
.card {
    background: var(--color-card);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-md);
    padding: 24px;
    transition: var(--transition);
}

.card:hover {
    box-shadow: var(--shadow-lg);
}

.card--no-padding {
    padding: 0;
    overflow: hidden;
}

/* ========================================
   CARD HEADER - Blue Header Style
   ======================================== */
.card__header {
    padding: 16px 24px;
    margin: 0;
}

.card__header--blue {
    background: var(--color-blue);
    color: white;
    border-radius: var(--radius-lg) var(--radius-lg) 0 0;
}

.card__title {
    margin: 0;
    font-size: 18px;
    font-weight: 700;
    letter-spacing: 0.3px;
    text-transform: uppercase;
}

.card__header--blue .card__title {
    color: white;
}

.card__content {
    padding: 24px;
}

/* ========================================
   HEADER SECTION
   ======================================== */
.dashboard__header {
    display: flex;
    justify-content: flex-end; /* Align items to the end of the flex container */
    align-items: center;
    padding: 28px 32px;
    gap: 24px; /* Add some space between elements if needed */
}

.dashboard__header .patient-info {
    margin-right: auto; /* Push patient-info to the left, effectively moving the button to the right */
}

.patient-info {
    display: flex;
    align-items: center;
    gap: 24px;
}

.patient-info__label {
    font-size: 18px;
    font-weight: 800;
    color: var(--color-primary);
    background: var(--color-primary-light);
    padding: 12px 24px;
    border-radius: var(--radius-md);
    letter-spacing: 0.5px;
}

.patient-info__data {
    display: flex;
    gap: 32px;
}

.patient-info__field {
    display: flex;
    flex-direction: column;
}

.patient-info__value {
    font-size: 18px;
    font-weight: 700;
    color: var(--color-text-dark);
}

.patient-info__caption {
    font-size: 13px;
    font-weight: 600;
    color: var(--color-text-light);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-top: 2px;
}

/* ========================================
   BUTTONS
   ======================================== */
.btn {
    font-family: inherit;
    font-size: 16px;
    font-weight: 700;
    padding: 14px 32px;
    border-radius: var(--radius-md);
    border: none;
    cursor: pointer;
    transition: var(--transition);
    letter-spacing: 0.5px;
}

.btn--outline {
    background: transparent;
    color: var(--color-text-dark);
    border: 2px solid var(--color-primary-light);
}

.btn--outline:hover {
    background: var(--color-primary-light);
    color: var(--color-primary);
    transform: translateY(-1px);
}

/* ========================================
   WELLBEING SECTION
   ======================================== */
.wellbeing {
    display: flex;
    gap: 24px;
    align-items: stretch;
}

.wellbeing__chart {
    flex: 0 0 160px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.wellbeing__diseases {
    flex: 1;
    padding-left: 24px;
    border-left: 1px solid var(--color-border);
}

.diseases-list {
    list-style: none;
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.diseases-list__item {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.diseases-list__name {
    font-size: 15px;
    font-weight: 600;
    color: var(--color-text-dark);
    text-transform: uppercase;
    letter-spacing: 0.3px;
}

.diseases-list__status {
    font-size: 14px;
    font-weight: 700;
    color: var(--color-warning);
    text-transform: uppercase;
}

.diseases-list__status--none {
    color: var(--color-text-light);
}

/* ========================================
   EVENTS SECTION
   ======================================== */
.events {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.events__header {
    display: flex;
    justify-content: space-between;
    padding-bottom: 16px;
    margin-bottom: 12px;
    border-bottom: 2px solid var(--color-border);
}

.events__title {
    font-size: 16px;
    font-weight: 700;
    color: var(--color-text-medium);
    text-transform: uppercase;
    letter-spacing: 0.3px;
}

.events__time-label {
    font-size: 14px;
    font-weight: 600;
    color: var(--color-text-light);
}

.events__list {
    flex: 1;
    overflow-y: auto;
    padding-right: 8px;
    max-height: 180px;
}

.events__item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 14px 0;
    border-bottom: 1px solid var(--color-border);
}

.events__item:last-child {
    border-bottom: none;
}

.events__name {
    font-size: 14px;
    font-weight: 600;
    color: var(--color-text-dark);
    flex: 1;
    padding-right: 16px;
}

.events__time {
    font-size: 14px;
    font-weight: 600;
    color: var(--color-text-medium);
    white-space: nowrap;
}

/* Custom Scrollbar */
.events__list::-webkit-scrollbar {
    width: 6px;
}

.events__list::-webkit-scrollbar-track {
    background: var(--color-border);
    border-radius: 10px;
}

.events__list::-webkit-scrollbar-thumb {
    background: var(--color-primary-light);
    border-radius: 10px;
}

.events__list::-webkit-scrollbar-thumb:hover {
    background: var(--color-primary);
}

/* ========================================
   KTG SECTION - DUAL CHART LAYOUT
   ======================================== */
.ktg {
    display: flex;
    flex-direction: column;
}

.ktg__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 24px;
}

.ktg__title {
    font-size: 22px;
    font-weight: 800;
    color: var(--color-text-dark);
}

.ktg__controls {
    display: flex;
    gap: 12px;
}

.ktg__print-btn {
    width: 36px;
    height: 36px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--color-border);
    background: white;
    color: var(--color-text-medium);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: var(--transition);
}

.ktg__print-btn:hover {
    background: var(--color-bg-secondary);
    color: var(--color-primary);
    border-color: var(--color-primary);
}

/* Chart Groups */
.ktg__chart-group {
    display: flex;
    margin-bottom: 0;
    position: relative;
    background: white;
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    overflow: hidden;
}

.ktg__chart-group:first-of-type {
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
    border-bottom: none;
}

.ktg__chart-group:last-of-type {
    border-top-left-radius: 0;
    border-top-right-radius: 0;
}

.ktg__chart-label {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 80px;
    background: var(--color-bg-secondary);
    border-right: 1px solid var(--color-border);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 4px;
    z-index: 1;
}

.ktg__chart-title {
    font-size: 13px;
    font-weight: 700;
    color: var(--color-text-dark);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.ktg__chart-units {
    font-size: 11px;
    font-weight: 600;
    color: var(--color-text-light);
}

/* Chart Containers */
.ktg__chart-container {
    flex: 1;
    position: relative;
    padding-left: 80px;
    background: white;
}

.ktg__chart-container--fhr {
    height: 240px;
    background: linear-gradient(180deg, 
        rgba(255,255,255,0) 0%, 
        rgba(255,255,255,0) calc(100% - 1px),
        #F0F0F3 calc(100% - 1px),
        #F0F0F3 100%
    );
}

.ktg__chart-container--ua {
    height: 120px;
}

/* Canvas styling for paper-like appearance */
.ktg__chart-container canvas {
    background-image: 
        repeating-linear-gradient(
            0deg,
            transparent,
            transparent 19px,
            rgba(0,0,0,0.03) 19px,
            rgba(0,0,0,0.03) 20px
        ),
        repeating-linear-gradient(
            90deg,
            transparent,
            transparent 19px,
            rgba(0,0,0,0.03) 19px,
            rgba(0,0,0,0.03) 20px
        );
}

/* ========================================
   TIMELINE & SCRUBBER
   ======================================== */
.ktg__timeline {
    display: flex;
    align-items: center;
    gap: 20px;
    padding: 0 8px;
    margin-top: 20px;
}

.ktg__time-start,
.ktg__time-end {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-size: 13px;
    font-weight: 600;
    color: var(--color-text-light);
    white-space: nowrap;
}

.ktg__scrubber {
    flex: 1;
    height: 40px;
    position: relative;
    display: flex;
    align-items: center;
    cursor: pointer;
}

.ktg__scrubber-track {
    width: 100%;
    height: 4px;
    background: var(--color-primary-light);
    border-radius: 2px;
}

.ktg__scrubber-handle {
    position: absolute;
    width: 24px;
    height: 24px;
    background: var(--color-primary);
    border: 4px solid white;
    border-radius: 50%;
    box-shadow: 0 2px 8px rgba(109, 99, 255, 0.4);
    cursor: grab;
    transform: translateX(-50%);
    transition: transform 0.1s ease;
}

.ktg__scrubber-handle:active {
    cursor: grabbing;
    transform: translateX(-50%) scale(1.1);
}

.ktg__scrubber-time {
    position: absolute;
    bottom: 32px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--color-primary);
    color: white;
    padding: 6px 12px;
    border-radius: var(--radius-sm);
    font-size: 13px;
    font-weight: 700;
    white-space: nowrap;
    pointer-events: none;
}

.ktg__scrubber-time::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 4px solid transparent;
    border-top-color: var(--color-primary);
}

/* ========================================
   ANIMATIONS
   ======================================== */
@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.card__header--blue {
    animation: fadeIn 0.3s ease-out;
}

/* ========================================
   HOVER EFFECTS
   ======================================== */
.dashboard__wellbeing:hover .card__header--blue {
    background: var(--color-blue-dark);
}

/* ========================================
   PRINT STYLES
   ======================================== */
@media print {
    body {
        background: white;
    }
    
    .dashboard {
        padding: 0;
    }
    
    .card {
        box-shadow: none;
        border: 1px solid #ddd;
        break-inside: avoid;
    }
    
    .ktg__print-btn {
        display: none;
    }
    
    .ktg__chart-container {
        background: white !important;
    }
    
    .ktg__chart-container canvas {
        background-image: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 9px,
                #000 9px,
                #000 10px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 9px,
                #000 9px,
                #000 10px
            ) !important;
    }
}

/* ========================================
   RESPONSIVE DESIGN
   ======================================== */
@media (max-width: 1024px) {
    .dashboard {
        grid-template-columns: 1fr;
        grid-template-areas:
            "header"
            "wellbeing"
            "events"
            "ktg";
    }
}

@media (max-width: 768px) {
    .dashboard {
        padding: 16px;
        gap: 16px;
    }
    
    .card {
        padding: 20px;
    }
    
    .card__header {
        padding: 14px 20px;
    }
    
    .card__title {
        font-size: 16px;
    }
    
    .card__content {
        padding: 20px;
    }
    
    .dashboard__header {
        flex-direction: column;
        gap: 20px;
        padding: 20px;
    }
    
    .patient-info {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .patient-info__data {
        flex-direction: column;
        gap: 16px;
    }
    
    .wellbeing {
        flex-direction: column;
        gap: 20px;
    }
    
    .wellbeing__chart {
        flex: 1;
    }
    
    .wellbeing__diseases {
        padding-left: 0;
        padding-top: 20px;
        border-left: none;
        border-top: 1px solid var(--color-border);
    }
    
    .ktg__header {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
    }
    
    .ktg__chart-label {
        width: 60px;
    }
    
    .ktg__chart-container {
        padding-left: 60px;
    }
    
    .ktg__chart-title {
        font-size: 11px;
    }
    
    .ktg__chart-units {
        font-size: 10px;
    }
    
    .ktg__chart-container--fhr {
        height: 180px;
    }
    
    .ktg__chart-container--ua {
        height: 90px;
    }
}

@media (max-width: 480px) {
    .dashboard {
        padding: 12px;
        gap: 12px;
    }
    
    .card {
        padding: 16px;
        border-radius: var(--radius-md);
    }
    
    .patient-info__label {
        font-size: 16px;
        padding: 10px 20px;
    }
    
    .patient-info__value {
        font-size: 16px;
    }
    
    .btn {
        padding: 12px 24px;
        font-size: 14px;
    }
    
    .ktg__timeline {
        flex-direction: column;
        gap: 16px;
    }
    
    .ktg__scrubber {
        width: 100%;
    }
}

/* ========================================
   UTILITIES
   ======================================== */
.visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

.text-center {
    text-align: center;
}

.text-right {
    text-align: right;
}

.mt-1 { margin-top: 8px; }
.mt-2 { margin-top: 16px; }
.mt-3 { margin-top: 24px; }
.mb-1 { margin-bottom: 8px; }
.mb-2 { margin-bottom: 16px; }
.mb-3 { margin-bottom: 24px; }

/* ========================================
   CARD HEADER - Updated for Events
   ======================================== */
.card__header--blue {
    background: #5A81FA;
    color: white;
    border-radius: var(--radius-lg) var(--radius-lg) 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.card__subtitle {
    font-size: 14px;
    font-weight: 600;
    color: white;
    opacity: 0.9;
}

/* ========================================
   EVENTS SECTION - Redesigned
   ======================================== */
.events {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.events__list {
    flex: 1;
    overflow-y: auto;
    max-height: 200px;
    padding-right: 8px;
}

.events__item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    margin-bottom: 8px;
    background: var(--color-bg-secondary);
    border-radius: var(--radius-md);
    border: 1px solid transparent;
    cursor: pointer;
    transition: var(--transition);
}

.events__item:hover {
    background: white;
    border-color: var(--color-primary-light);
    transform: translateX(4px);
    box-shadow: var(--shadow-sm);
}

.events__item:active {
    transform: translateX(2px);
    background: var(--color-primary-light);
}

.events__item--active {
    background: var(--color-primary-light);
    border-color: var(--color-primary);
}

.events__item:last-child {
    margin-bottom: 0;
}

.events__name {
    font-size: 14px;
    font-weight: 600;
    color: var(--color-text-dark);
    flex: 1;
    padding-right: 16px;
}

.events__time {
    font-size: 14px;
    font-weight: 700;
    color: var(--color-primary);
    white-space: nowrap;
    min-width: 60px;
    text-align: right;
}

/* Custom Scrollbar for Events */
.events__list::-webkit-scrollbar {
    width: 6px;
}

.events__list::-webkit-scrollbar-track {
    background: var(--color-border);
    border-radius: 10px;
}

.events__list::-webkit-scrollbar-thumb {
    background: #5A81FA;
    border-radius: 10px;
    opacity: 0.5;
}

.events__list::-webkit-scrollbar-thumb:hover {
    background: #4A71EA;
    opacity: 1;
}
/* ========================================
   NOTIFICATIONS
   ======================================== */
.notification {
    position: fixed;
    top: 20px;
    right: 20px;
    min-width: 300px;
    max-width: 500px;
    background: white;
    border-radius: var(--radius-md);
    box-shadow: var(--shadow-lg);
    transform: translateX(400px);
    transition: transform 0.3s ease;
    z-index: 1000;
}

.notification--show {
    transform: translateX(0);
}

.notification__content {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 20px;
}

.notification--info {
    border-left: 4px solid var(--color-primary);
}

.notification--warning {
    border-left: 4px solid var(--color-warning);
}

.notification--error,
.notification--high {
    border-left: 4px solid var(--color-danger);
}

.notification--medium {
    border-left: 4px solid var(--color-warning);
}

.notification__message {
    flex: 1;
    font-size: 14px;
    font-weight: 600;
    color: var(--color-text-dark);
}

.notification__close {
    background: none;
    border: none;
    font-size: 24px;
    color: var(--color-text-light);
    cursor: pointer;
    padding: 0;
    margin-left: 16px;
}

.notification__close:hover {
    color: var(--color-text-dark);
}

/* Risk level indicators */
.risk-low {
    --risk-color: var(--color-success);
}

.risk-medium {
    --risk-color: var(--color-warning);
}

.risk-high {
    --risk-color: var(--color-danger);
}

.risk-critical {
    --risk-color: #B71C1C;
}

.dashboard__wellbeing.risk-medium .card__header--blue,
.dashboard__wellbeing.risk-high .card__header--blue,
.dashboard__wellbeing.risk-critical .card__header--blue {
    background: var(--risk-color);
}

/* Connection status indicator */
#connectionStatus {
    position: fixed;
    bottom: 20px;
    left: 20px;
    padding: 8px 16px;
    background: var(--color-danger);
    color: white;
    border-radius: var(--radius-sm);
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    transition: all 0.3s ease;
}

#connectionStatus.connected {
    background: var(--color-success);
}

/* ========================================
   WELLBEING INDICATORS & ANIMATIONS
   ======================================== */

/* Pulse animation for critical values */
@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(255, 91, 91, 0.7);
    }
    70% {
        box-shadow: 0 0 0 10px rgba(255, 91, 91, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(255, 91, 91, 0);
    }
}

.pulse-animation {
    animation: pulse 2s infinite;
}

/* Wellbeing status colors */
.wellbeing--good {
    --status-color: #2ED47A;
}

.wellbeing--normal {
    --status-color: #FFC107;
}

.wellbeing--warning {
    --status-color: #FFB946;
}

.wellbeing--critical {
    --status-color: #FF5B5B;
    animation: pulse 2s infinite;
}

.wellbeing--good .card__header--blue {
    background: var(--status-color) !important;
}

.wellbeing--warning .card__header--blue {
    background: var(--status-color) !important;
}

.wellbeing--critical .card__header--blue {
    background: var(--status-color) !important;
}

/* Smooth transitions for color changes */
.dashboard__wellbeing .card__header {
    transition: background-color 0.5s ease;
}

/* Disease status indicators */
.diseases-list__status {
    transition: all 0.3s ease;
}

.diseases-list__status--active {
    color: var(--color-danger);
    font-weight: 700;
}

.diseases-list__status--warning {
    color: var(--color-warning);
}
/* ========================================
   WELLBEING SCALE INDICATOR
   ======================================== */
.wellbeing__scale {
    margin-top: 16px;
    padding-top: 16px;
    border-top: 1px solid var(--color-border);
}

.wellbeing__scale-bar {
    position: relative;
    height: 8px;
    background: #F0F0F3;
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 8px;
}

.wellbeing__scale-fill {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    border-radius: 4px;
    transition: all 0.5s ease;
    background: #2ED47A;
}

.wellbeing__scale-labels {
    display: flex;
    justify-content: space-between;
    font-size: 10px;
    font-weight: 600;
    color: #9A9AAB;
    margin-top: 4px;
}

.wellbeing__scale-text {
    text-align: center;
    margin-top: 12px;
}

.wellbeing__scale-value {
    font-size: 24px;
    font-weight: 800;
    color: var(--color-text-dark);
}

.wellbeing__scale-max {
    font-size: 12px;
    font-weight: 600;
    color: #9A9AAB;
    margin-left: 4px;
}
/* ========================================
   HISTORY PAGE STYLES
   ======================================== */

/* History Page Layout */
.history-page {
    max-width: 1440px;
    margin: 0 auto;
    padding: 24px;
    min-height: 100vh;
}

.history-page__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 32px;
    padding: 20px 0;
    border-bottom: 2px solid var(--color-border);
}

.history-page__nav {
    flex: 0 0 auto;
}

.history-page__title {
    flex: 1;
    text-align: center;
    font-size: 28px;
    font-weight: 800;
    color: var(--color-text-dark);
    margin: 0;
    letter-spacing: -0.5px;
}

.history-page__actions {
    flex: 0 0 auto;
}

/* Back Button */
.btn-back {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    background: transparent;
    color: var(--color-primary);
    border: 2px solid var(--color-primary-light);
    border-radius: var(--radius-md);
    text-decoration: none;
    font-weight: 600;
    font-size: 15px;
    transition: var(--transition);
}

.btn-back:hover {
    background: var(--color-primary-light);
    transform: translateX(-2px);
}

.btn-back svg {
    transition: var(--transition);
}

.btn-back:hover svg {
    transform: translateX(-2px);
}

/* Secondary Button */
.btn--secondary {
    background: var(--color-bg-secondary);
    color: var(--color-text-dark);
    border: 1px solid var(--color-border);
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

.btn--secondary:hover {
    background: white;
    border-color: var(--color-primary-light);
}

/* History Cards Container */
.history-page__container {
    width: 100%;
}

.history-cards {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
    gap: 24px;
}

/* History Card */
.history-card {
    background: var(--color-card);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-md);
    padding: 24px;
    transition: all 0.3s ease;
    opacity: 0;
    transform: translateY(10px);
    cursor: pointer;
}

.history-card--visible {
    opacity: 1;
    transform: translateY(0);
}

.history-card:hover {
    box-shadow: var(--shadow-lg);
    transform: translateY(-2px);
}

/* Card Header */
.history-card__header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 20px;
    padding-bottom: 16px;
    border-bottom: 2px solid var(--color-border);
}

.history-card__datetime {
    flex: 1;
}

.history-card__date {
    font-size: 18px;
    font-weight: 700;
    color: var(--color-text-dark);
    margin-bottom: 4px;
}

.history-card__time {
    font-size: 14px;
    font-weight: 600;
    color: var(--color-text-light);
}

/* Outcome Badge */
.history-card__outcome {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 12px;
    border-radius: var(--radius-sm);
    font-size: 13px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.3px;
}

.history-card__outcome--normal {
    background: rgba(46, 212, 122, 0.1);
    color: var(--color-success);
}

.history-card__outcome--warning {
    background: rgba(255, 185, 70, 0.1);
    color: var(--color-warning);
}

.history-card__outcome--pathological {
    background: rgba(255, 91, 91, 0.1);
    color: var(--color-danger);
}

.history-card__outcome-icon {
    font-size: 16px;
    font-weight: 800;
}

/* Metrics Section */
.history-card__metrics {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
    margin-bottom: 20px;
}

.history-card__metric {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 12px;
    background: var(--color-bg-secondary);
    border-radius: var(--radius-md);
}

.history-card__metric-label {
    font-size: 11px;
    font-weight: 600;
    color: var(--color-text-light);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
}

.history-card__metric-value {
    font-size: 20px;
    font-weight: 800;
    color: var(--color-text-dark);
}

.history-card__metric-value--score {
    color: var(--color-primary);
}

/* Events Section */
.history-card__events {
    display: flex;
    justify-content: space-around;
    padding: 16px;
    background: linear-gradient(135deg, var(--color-primary-light) 0%, rgba(90, 129, 250, 0.05) 100%);
    border-radius: var(--radius-md);
    margin-bottom: 20px;
}

.history-card__event {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 13px;
}

.history-card__event-icon {
    font-size: 18px;
    font-weight: 800;
    color: var(--color-primary);
}

.history-card__event-count {
    font-size: 16px;
    font-weight: 700;
    color: var(--color-text-dark);
}

.history-card__event-label {
    font-weight: 500;
    color: var(--color-text-medium);
}

/* Card Footer */
.history-card__footer {
    display: flex;
    justify-content: center;
}

.history-card__details-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 12px 24px;
    background: var(--color-primary);
    color: white;
    border-radius: var(--radius-md);
    text-decoration: none;
    font-weight: 600;
    font-size: 14px;
    transition: var(--transition);
    width: 100%;
    justify-content: center;
}

.history-card__details-btn:hover {
    background: var(--color-primary-dark);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(109, 99, 255, 0.3);
}

.history-card__details-btn svg {
    transition: var(--transition);
}

.history-card__details-btn:hover svg {
    transform: translateX(2px);
}

/* Empty State */
.history-empty {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 400px;
    text-align: center;
    padding: 48px;
}

.history-empty__icon {
    margin-bottom: 24px;
    color: var(--color-text-light);
    opacity: 0.5;
}

.history-empty__title {
    font-size: 24px;
    font-weight: 700;
    color: var(--color-text-dark);
    margin-bottom: 12px;
}

.history-empty__text {
    font-size: 16px;
    color: var(--color-text-medium);
    max-width: 400px;
}

/* ========================================
   HISTORY PAGE - EXACT MONITORING STYLE
   ======================================== */

.history-page {
    max-width: 1440px;
    margin: 0 auto;
    padding: 24px;
    min-height: 100vh;
    background: var(--color-bg);
}

/* Header */
.history-page__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 48px; /* Увеличенный отступ */
    padding-bottom: 24px;
    border-bottom: 2px solid var(--color-border);
}

.history-page__nav {
    flex: 0 0 auto;
}

.history-page__title {
    flex: 1;
    text-align: center;
    font-size: 26px;
    font-weight: 800;
    color: var(--color-text-dark);
    margin: 0;
}

.history-page__filters {
    display: flex;
    gap: 12px;
    align-items: center;
}

/* Date Filter */
.date-filter {
    padding: 10px 16px;
    border: 2px solid var(--color-border);
    border-radius: var(--radius-md);
    font-family: var(--font-family);
    font-size: 14px;
    font-weight: 600;
    color: var(--color-text-dark);
    background: white;
    cursor: pointer;
    transition: var(--transition);
}

.date-filter:hover {
    border-color: var(--color-primary-light);
}

.date-filter:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 3px rgba(109, 99, 255, 0.1);
}

/* Back Button */
.btn-back {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    background: transparent;
    color: var(--color-primary);
    border: 2px solid var(--color-primary-light);
    border-radius: var(--radius-md);
    text-decoration: none;
    font-weight: 600;
    font-size: 15px;
    transition: var(--transition);
}

.btn-back:hover {
    background: var(--color-primary-light);
    transform: translateX(-2px);
}

/* Secondary Button */
.btn--secondary {
    background: white;
    color: var(--color-text-dark);
    border: 2px solid var(--color-border);
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 10px 16px;
    font-size: 14px;
}

.btn--secondary:hover {
    background: var(--color-bg-secondary);
    border-color: var(--color-primary-light);
}

/* Sessions Container с большими отступами */
.history-sessions {
    display: flex;
    flex-direction: column;
    gap: 60px; /* БОЛЬШОЕ расстояние между блоками */
}

/* Session Block */
.history-session-block {
    animation: fadeInUp 0.5s ease-out;
}

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Session Header */
.history-session-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 28px;
    background: white;
    border-radius: var(--radius-lg) var(--radius-lg) 0 0;
    box-shadow: var(--shadow-sm);
    margin-bottom: -1px;
    position: relative;
    z-index: 1;
}

.history-session-info {
    flex: 1;
}

.history-session-date {
    font-size: 22px;
    font-weight: 700;
    color: var(--color-text-dark);
    margin: 0 0 6px 0;
    text-transform: capitalize;
}

.history-session-time {
    display: flex;
    align-items: center;
    gap: 12px;
    font-size: 14px;
    font-weight: 600;
    color: var(--color-text-medium);
}

.history-session-separator {
    color: var(--color-text-light);
}

/* Session Badges */
.history-session-badges {
    display: flex;
    gap: 16px;
}

.session-badge {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 12px 20px;
    background: var(--color-bg-secondary);
    border-radius: var(--radius-md);
    min-width: 100px;
}

.session-badge-label {
    font-size: 11px;
    font-weight: 600;
    color: var(--color-text-light);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
}

.session-badge-value {
    font-size: 24px;
    font-weight: 800;
    color: var(--color-text-dark);
}

.session-badge--fischer {
    background: linear-gradient(135deg, #E8E6FF 0%, #F4F7FE 100%);
}

.session-badge--fischer .session-badge-value {
    color: var(--color-primary);
}

.session-badge--wellbeing {
    background: linear-gradient(135deg, 
        color-mix(in srgb, var(--wb-color) 10%, white) 0%, 
        color-mix(in srgb, var(--wb-color) 5%, white) 100%);
    border: 2px solid var(--wb-color);
}

.session-badge--wellbeing .session-badge-value {
    color: var(--wb-color);
}

.session-badge-status {
    font-size: 10px;
    font-weight: 700;
    color: var(--wb-color);
    text-transform: uppercase;
    margin-top: 2px;
}

/* История KTG - используем те же стили что и на главной */
.history-ktg {
    /* Используем стили из основного КТГ */
    position: relative;
    border-radius: 0 0 var(--radius-lg) var(--radius-lg);
}

/* No Data Overlay */
.ktg__no-data-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(5px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
    border-radius: var(--radius-lg);
}

.ktg__no-data-message {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    padding: 32px;
    text-align: center;
}

.ktg__no-data-message svg {
    color: var(--color-text-light);
    opacity: 0.5;
}

.ktg__no-data-message span {
    font-size: 16px;
    font-weight: 600;
    color: var(--color-text-medium);
}

/* Placeholder State */
.history-placeholder {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    flex-direction: column;
    align-items: center;
    text-align: center;
    padding: 48px;
    background: white;
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-lg);
    z-index: 100;
    animation: fadeIn 0.3s ease-out;
}

.history-placeholder__icon {
    margin-bottom: 24px;
    color: var(--color-primary);
    animation: pulse 1.5s ease-in-out infinite;
}

.history-placeholder__title {
    font-size: 20px;
    font-weight: 700;
    color: var(--color-text-dark);
    margin-bottom: 8px;
}

.history-placeholder__text {
    font-size: 14px;
    color: var(--color-text-medium);
    max-width: 300px;
}

@keyframes pulse {
    0%, 100% {
        transform: scale(1);
        opacity: 1;
    }
    50% {
        transform: scale(1.1);
        opacity: 0.7;
    }
}

/* Responsive Design */
@media (max-width: 1024px) {
    .history-sessions {
        gap: 40px; /* Меньше на планшетах */
    }
    
    .history-session-header {
        flex-direction: column;
        gap: 20px;
        align-items: flex-start;
    }
    
    .history-session-badges {
        width: 100%;
    }
}

@media (max-width: 768px) {
    .history-page {
        padding: 16px;
    }
    
    .history-page__header {
        flex-direction: column;
        gap: 16px;
        align-items: stretch;
        margin-bottom: 32px;
    }
    
    .history-page__title {
        font-size: 22px;
        text-align: left;
    }
    
    .history-page__filters {
        flex-direction: column;
        width: 100%;
    }
    
    .date-filter,
    .btn--secondary {
        width: 100%;
        justify-content: center;
    }
    
    .btn-back {
        width: 100%;
        justify-content: center;
    }
    
    .history-sessions {
        gap: 32px; /* Меньше на мобильных */
    }
    
    .history-session-date {
        font-size: 18px;
    }
    
    .history-session-time {
        flex-direction: column;
        align-items: flex-start;
        gap: 4px;
    }
    
    .history-session-separator {
        display: none;
    }
    
    .session-badge {
        min-width: 80px;
        padding: 8px 12px;
    }
    
    .session-badge-value {
        font-size: 20px;
    }
}

@media (max-width: 480px) {
    .history-sessions {
        gap: 24px;
    }
}

/* Link styles fix */
a.btn {
    text-decoration: none;
    display: inline-block;
}

a.btn--outline {
    text-align: center;
}
/* Header Controls */
.header-controls {
    display: flex;
    gap: 12px;
    align-items: center;
}

.btn--primary {
    background-color: var(--color-primary);
    color: white;
    border: 2px solid var(--color-primary);
}

.btn--primary:hover {
    background-color: var(--color-primary-dark);
    border-color: var(--color-primary-dark);
    transform: translateY(-1px);
}


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\guardian_angel\ml_model.pkl
================================================================================

[Ошибка чтения файла: 'utf-8' codec can't decode byte 0x80 in position 0: invalid start byte]


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\guardian_angel\main.py
================================================================================

import json
import socket
import time
import os
import sys
sys.path.append(os.path.dirname(__file__))
from db_manager import DBManager

HOST = '127.0.0.1'
PORT = 65432

def safe_int(x, fallback=None):
    try:
        return int(float(x))
    except Exception:
        return fallback

def safe_float(x, fallback=None):
    try:
        return float(x)
    except Exception:
        return fallback

def start_receive():
    db = DBManager()
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((HOST, PORT))
        buffer = ''
        while True:
            data = s.recv(4096)
            if not data:
                break
            buffer += data.decode('utf-8', errors='ignore')
            while '\n' in buffer:
                line, buffer = buffer.split('\n', 1)
                if not line.strip():
                    continue
                try:
                    data_json = json.loads(line)
                    ts = int(time.time())
                    bpm = data_json.get('bpm', [None, None])
                    uterus = data_json.get('uterus', [None, None])
                    bpm_time = safe_float(bpm[0], fallback=None)
                    bpm_value = safe_float(bpm[1], fallback=None)
                    uterus_time = safe_float(uterus[0], fallback=None)
                    uterus_value = safe_float(uterus[1], fallback=None)
                    db.add(ts, bpm_time, bpm_value, uterus_time, uterus_value)
                    print(f"Buffered: ts={ts}, bpm_time={bpm_time}, bpm_value={bpm_value}, uterus_time={uterus_time}, uterus_value={uterus_value}")
                except Exception as e:
                    print(f"Error parsing message: {e}")

if __name__ == '__main__':
    start_receive()


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\guardian_angel\guardian_angel_data.db
================================================================================

[Ошибка чтения файла: 'utf-8' codec can't decode byte 0xf9 in position 106: invalid start byte]


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\guardian_angel\final_prediction_service.py
================================================================================

"""
final_prediction_service.py

Production-ready сервис для анализа КТГ в реальном времени
Версия 2.2.0 - с поддержкой временных меток для всех событий
"""

import os
import pickle
import numpy as np
import pandas as pd
import asyncio
import aiosqlite
import json
import logging
from typing import Dict, Any, List, Tuple, Optional
from datetime import datetime, timedelta
from scipy import signal as scipy_signal
from scipy.stats import skew, kurtosis
from scipy.interpolate import interp1d
import warnings
warnings.filterwarnings('ignore')

__version__ = "2.2.0"
__author__ = "CTG Analysis Team"

# ============================================================================
# НАСТРОЙКА ЛОГИРОВАНИЯ
# ============================================================================
os.makedirs('logs', exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/ctg_analysis.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# ============================================================================
# КОНСТАНТЫ
# ============================================================================
ORIGINAL_SAMPLING_RATE = 1
TARGET_SAMPLING_RATE = 4
INTERPOLATION_FACTOR = TARGET_SAMPLING_RATE // ORIGINAL_SAMPLING_RATE

LONG_WINDOW_MINUTES = 10
SHORT_WINDOW_MINUTES = 0.25
LONG_WINDOW_SAMPLES = LONG_WINDOW_MINUTES * 60 * TARGET_SAMPLING_RATE
SHORT_WINDOW_SAMPLES = int(SHORT_WINDOW_MINUTES * 60 * TARGET_SAMPLING_RATE)

SHORT_PATTERN_MIN_DURATION = 5 * TARGET_SAMPLING_RATE
SHORT_PROLONGED_DURATION = 30 * TARGET_SAMPLING_RATE
ANALYSIS_INTERVAL_SECONDS = 15

# ============================================================================
# ЭКСТРАКТОР ПРИЗНАКОВ С ПОДДЕРЖКОЙ ИНТЕРПОЛЯЦИИ
# ============================================================================
class CTGFeatureExtractor:
    """
    Извлекает признаки из сырых данных КТГ с поддержкой интерполяции
    """
    def __init__(self, sampling_rate: int = TARGET_SAMPLING_RATE):
        self.sampling_rate = sampling_rate
        self.logger = logging.getLogger(f"{__name__}.CTGFeatureExtractor")
        
    def interpolate_signal(self, signal_1hz: np.ndarray) -> np.ndarray:
        if len(signal_1hz) < 2:
            return signal_1hz
        x_original = np.arange(len(signal_1hz))
        x_interpolated = np.linspace(0, len(signal_1hz) - 1, len(signal_1hz) * INTERPOLATION_FACTOR)
        f = interp1d(x_original, signal_1hz, kind='linear', fill_value='extrapolate')
        return f(x_interpolated)
    
    def extract_features(self, fhr: np.ndarray, uc: np.ndarray, window_type: str = 'long') -> Dict[str, float]:
        features = {}
        min_pattern_duration = SHORT_PATTERN_MIN_DURATION if window_type == 'short' else 15 * self.sampling_rate
        prolonged_duration = SHORT_PROLONGED_DURATION if window_type == 'short' else 90 * self.sampling_rate
        
        signal_loss_mask = (fhr == 0) | (fhr < 50) | (fhr > 210)
        signal_loss_ratio = np.sum(signal_loss_mask) / len(fhr) if len(fhr) > 0 else 0
        features['signal_loss_ratio'] = signal_loss_ratio
        
        fhr_clean = self._clean_signal(fhr, signal_loss_mask)
        baseline = self._calculate_baseline(fhr_clean)
        
        features.update({
            'baseline_bpm': baseline,
            'fhr_median': baseline,
            'fhr_mean': np.mean(fhr_clean),
            'fhr_std': np.std(fhr_clean),
            'fhr_min': np.min(fhr_clean),
            'fhr_max': np.max(fhr_clean),
            'fhr_q25': np.percentile(fhr_clean, 25),
            'fhr_q75': np.percentile(fhr_clean, 75),
            'fhr_iqr': np.percentile(fhr_clean, 75) - np.percentile(fhr_clean, 25),
            'stv': self._calculate_stv(fhr_clean),
            'ltv': self._calculate_stv(fhr_clean) * 2 if window_type == 'short' else self._calculate_ltv(fhr_clean),
            'variability': self._calculate_stv(fhr_clean) * 2 if window_type == 'short' else self._calculate_ltv(fhr_clean)
        })
        
        patterns = self._detect_patterns(fhr_clean, baseline, min_pattern_duration, prolonged_duration)
        features.update(patterns)
        
        uc_clean = uc[uc > 0] if len(uc) > 0 and np.any(uc > 0) else np.array([0])
        features.update({
            'uc_mean': np.mean(uc_clean),
            'uc_max': np.max(uc_clean),
            'uc_std': np.std(uc_clean),
            'fhr_entropy': self._calculate_entropy(fhr_clean),
            'fhr_skewness': skew(fhr_clean) if len(fhr_clean) > 1 else 0,
            'fhr_kurtosis': kurtosis(fhr_clean) if len(fhr_clean) > 1 else 0,
            'accelerations': patterns.get('accelerations_count', 0),
            'decelerations': patterns.get('decelerations_count', 0)
        })
        
        return features
    
    def _clean_signal(self, fhr: np.ndarray, signal_loss_mask: np.ndarray) -> np.ndarray:
        clean_fhr = np.copy(fhr)
        valid_mask = ~signal_loss_mask
        if np.sum(valid_mask) > 0:
            median_val = np.median(fhr[valid_mask])
            clean_fhr[signal_loss_mask] = median_val
        return clean_fhr
    
    def _calculate_baseline(self, fhr: np.ndarray) -> float:
        if len(fhr) == 0:
            return 140
        p10, p90 = np.percentile(fhr, [10, 90])
        trimmed = fhr[(fhr >= p10) & (fhr <= p90)]
        return np.median(trimmed) if len(trimmed) > 0 else np.median(fhr)
    
    def _calculate_stv(self, fhr: np.ndarray) -> float:
        return np.mean(np.abs(np.diff(fhr))) if len(fhr) >= 2 else 0
    
    def _calculate_ltv(self, fhr: np.ndarray) -> float:
        if len(fhr) < 10:
            return self._calculate_stv(fhr) * 2
        p5, p95 = np.percentile(fhr, [5, 95])
        trimmed = fhr[(fhr >= p5) & (fhr <= p95)]
        return np.std(trimmed) if len(trimmed) > 10 else np.std(fhr)
    
    def _detect_patterns(self, fhr: np.ndarray, baseline: float, min_duration: int, prolonged_duration: int) -> Dict[str, int]:
        patterns = {}
        accel_threshold = baseline + 15
        decel_threshold = baseline - 15
        deep_threshold = baseline - 30
        
        above_accel = fhr > accel_threshold
        accel_segments = self._find_segments(above_accel, min_duration)
        patterns['accelerations_count'] = len(accel_segments)
        
        below_decel = fhr < decel_threshold
        decel_segments = self._find_segments(below_decel, min_duration)
        patterns['decelerations_count'] = len(decel_segments)
        
        deep_count = prolonged_count = 0
        for start, end in decel_segments:
            if np.min(fhr[start:end]) < deep_threshold:
                deep_count += 1
            if end - start >= prolonged_duration:
                prolonged_count += 1
        patterns['deep_decelerations_count'] = deep_count
        patterns['prolonged_decelerations'] = prolonged_count
        
        return patterns
    
    def _find_segments(self, mask: np.ndarray, min_length: int) -> List[Tuple[int, int]]:
        segments = []
        in_segment = False
        start = 0
        for i in range(len(mask)):
            if mask[i] and not in_segment:
                in_segment = True
                start = i
            elif not mask[i] and in_segment:
                in_segment = False
                if i - start >= min_length:
                    segments.append((start, i))
        if in_segment and len(mask) - start >= min_length:
            segments.append((start, len(mask)))
        return segments
    
    def _calculate_entropy(self, signal: np.ndarray, bins: int = 10) -> float:
        if len(signal) == 0:
            return 0
        hist, _ = np.histogram(signal, bins=bins)
        hist = hist[hist > 0]
        if len(hist) == 0:
            return 0
        probs = hist / np.sum(hist)
        return -np.sum(probs * np.log2(probs + 1e-10))

# ============================================================================
# КАЛЬКУЛЯТОР ШКАЛЫ ФИШЕРА С ПОВЫШЕННОЙ ЧУВСТВИТЕЛЬНОСТЬЮ
# ============================================================================
class FischerScoreCalculator:
    """
    Расчет баллов по шкале Фишера с повышенной чувствительностью к патологиям
    """
    def calculate(self, features: Dict[str, float]) -> Dict[str, Any]:
        scores = {}
        baseline = features.get('baseline_bpm', 140)
        scores['baseline'] = 2 if 110 <= baseline <= 160 else 1 if (100 <= baseline < 110 or 160 < baseline <= 170) else 0
        
        variability = features.get('variability', 0)
        scores['variability'] = 2 if variability >= 5 else 1 if variability >= 3 else 0
        
        accel_count = features.get('accelerations_count', 0)
        scores['accelerations'] = 2 if accel_count >= 2 else 1 if accel_count >= 1 else 0
        
        decel_count = features.get('decelerations_count', 0)
        deep_decel = features.get('deep_decelerations_count', 0)
        prolonged_decel = features.get('prolonged_decelerations', 0)
        scores['decelerations'] = 2 if decel_count == 0 else 1 if decel_count == 1 and deep_decel == 0 and prolonged_decel == 0 else 0
        
        scores['movements'] = scores['accelerations']
        total_score = sum(scores.values())
        
        interpretation, risk_category = ("Normal", "LOW") if total_score >= 8 else ("Suspicious", "MODERATE") if total_score >= 6 else ("Pathological", "HIGH")
        
        return {
            'total_score': total_score,
            'max_score': 10,
            'interpretation': interpretation,
            'risk_category': risk_category,
            'detailed_scores': scores
        }

# ============================================================================
# АНАЛИЗАТОР ТРЕНДОВ
# ============================================================================
class TrendAnalyzer:
    """
    Анализ трендов для оценки динамики состояния плода
    """
    def analyze(self, history_df: pd.DataFrame) -> Dict[str, Any]:
        if len(history_df) < LONG_WINDOW_SAMPLES:
            return {
                'status': 'insufficient_data',
                'description': 'Недостаточно данных для анализа тренда',
                'confidence': 0.0,
                'trend_score': 0.5,
                'baseline_change': 0,
                'recent_change': 0
            }
        
        fhr = history_df['fhr'].values
        third = len(fhr) // 3
        first_third_median = np.median(fhr[:third])
        middle_third_median = np.median(fhr[third:2*third])
        last_third_median = np.median(fhr[-third:])
        
        total_change = last_third_median - first_third_median
        recent_change = last_third_median - middle_third_median
        
        if abs(total_change) < 5:
            status, description, trend_score = 'stable', 'Стабильное состояние', 0.0
        elif total_change > 10:
            status, description, trend_score = 'increasing', 'Повышение базального ритма', 0.3
        elif total_change < -10:
            status, description, trend_score = 'decreasing', 'Снижение базального ритма', 0.4
        elif recent_change < -5:
            status, description, trend_score = 'deteriorating', 'Ухудшение в последнее время', 0.5
        else:
            status, description, trend_score = 'stable', 'Незначительные изменения', 0.1
        
        confidence = min(1.0, len(history_df) / LONG_WINDOW_SAMPLES)
        
        return {
            'status': status,
            'description': description,
            'confidence': confidence,
            'trend_score': trend_score,
            'baseline_change': total_change,
            'recent_change': recent_change
        }

# ============================================================================
# ГЛАВНЫЙ СЕРВИС ПРЕДСКАЗАНИЙ С АСИНХРОННОЙ ПОДДЕРЖКОЙ
# ============================================================================
class PredictionService:
    """
    Главный сервис для анализа КТГ с поддержкой реального времени
    """
    def __init__(self, model_path: str = "ml_model.pkl", db_path: str = "guardian_angel_data.db"):
        self.logger = logging.getLogger(f"{__name__}.PredictionService")
        self.feature_extractor = CTGFeatureExtractor()
        self.fischer_calculator = FischerScoreCalculator()
        self.trend_analyzer = TrendAnalyzer()
        self.db_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), db_path) if db_path else os.path.join(os.path.dirname(os.path.abspath(__file__)), 'guardian_angel_data.db')
        self.model_path = model_path
        self.model = None
        self.scaler = None
        self.model_available = False
        self.model_threshold = 0.5
        self.feature_names = None
        self._load_ml_model(model_path)
        self.last_analysis_result = {}
        self.analysis_history = []
        self.version = __version__
        self.initialized_at = datetime.now()
        self.logger.info(f"PredictionService v{self.version} initialized")
        self.logger.info(f"ML Model: {'Loaded' if self.model_available else 'Not Available'}")
    
    def _load_ml_model(self, model_path: str):
        try:
            if os.path.exists(model_path):
                with open(model_path, 'rb') as f:
                    model_data = pickle.load(f)
                self.model = model_data.get('model')
                self.scaler = model_data.get('scaler')
                self.model_threshold = model_data.get('optimal_threshold', 0.5)
                if hasattr(self.scaler, 'feature_names_in_'):
                    self.feature_names = self.scaler.feature_names_in_
                self.model_available = True
                self.logger.info(f"ML model loaded from {model_path}")
            else:
                self.logger.warning(f"ML model file not found: {model_path}")
        except Exception as e:
            self.logger.error(f"Error loading ML model: {e}")
            self.model_available = False
    
    async def get_data_from_db(self, limit: int = 600) -> pd.DataFrame:
        async with aiosqlite.connect(self.db_path) as db:
            query = """
            SELECT ts, bpm_time as time_sec, bpm_value as fhr, uterus_value as uc
            FROM ctg_data
            ORDER BY id DESC
            LIMIT ?
            """
            async with db.execute(query, (limit,)) as cursor:
                rows = await cursor.fetchall()
                if not rows:
                    return pd.DataFrame()
                df = pd.DataFrame(rows, columns=['ts', 'time_sec', 'fhr', 'uc'])
                return df.iloc[::-1].reset_index(drop=True)
    
    async def save_analysis_result(self, result: Dict[str, Any]):
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                CREATE TABLE IF NOT EXISTS analysis_results (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    ts INTEGER,
                    fwbs REAL,
                    action_priority TEXT,
                    urgency_level INTEGER,
                    baseline_fhr REAL,
                    variability REAL,
                    accelerations INTEGER,
                    decelerations INTEGER,
                    signal_quality REAL,
                    ml_probability REAL,
                    fischer_score INTEGER,
                    trend_status TEXT,
                    full_result TEXT
                )
            ''')
            await db.execute('''
                INSERT INTO analysis_results (
                    ts, fwbs, action_priority, urgency_level,
                    baseline_fhr, variability, accelerations, decelerations,
                    signal_quality, ml_probability, fischer_score, trend_status,
                    full_result
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                int(datetime.now().timestamp()),
                result.get('fetal_wellbeing_index', 0),
                result.get('action_priority', 'UNKNOWN'),
                result.get('urgency_level', 0),
                result.get('baseline_fhr', 0),
                result.get('variability', 0),
                result.get('accelerations', 0),
                result.get('decelerations', 0),
                result.get('signal_quality', 0),
                result.get('ml_probability', 0),
                result.get('fischer_score', 0),
                result.get('trend_status', 'unknown'),
                json.dumps(result)
            ))
            await db.commit()
            self.logger.info("Analysis result saved to database")
    
    def _predict_with_ml(self, features: Dict[str, float]) -> Dict[str, Any]:
        if not self.model_available:
            self.logger.warning("ML model unavailable, falling back to expert rules")
            return self._predict_with_rules(features)
        try:
            self.logger.info(f"Expected features: {self.feature_names}")
            self.logger.info(f"Provided features: {list(features.keys())}")
            if self.feature_names is not None:
                feature_vector = np.array([features.get(name, 0) for name in self.feature_names])
                if len(feature_vector) != len(self.feature_names):
                    self.logger.error(f"Feature vector length mismatch: expected {len(self.feature_names)}, got {len(feature_vector)}")
                    return self._predict_with_rules(features)
            else:
                feature_vector = np.array([features[key] for key in sorted(features.keys())])
            
            self.logger.info(f"Feature vector: {feature_vector}")
            self.logger.info(f"Feature vector shape: {feature_vector.shape}")
            feature_scaled = self.scaler.transform(feature_vector.reshape(1, -1))
            probability = self.model.predict_proba(feature_scaled)[0, 1]
            risk_level = "CRITICAL" if probability > 0.75 else "HIGH" if probability > 0.5 else "MODERATE" if probability > 0.25 else "LOW"
            return {
                'hypoxia_probability': float(probability),
                'risk_level': risk_level,
                'confidence': 0.95,
                'method': 'ml_model'
            }
        except Exception as e:
            self.logger.error(f"ML prediction failed: {e}")
            return self._predict_with_rules(features)
    
    def _predict_with_rules(self, features: Dict[str, float]) -> Dict[str, Any]:
        risk_score = 0.0
        risk_factors = []
        baseline = features.get('baseline_bpm', 140)
        variability = features.get('variability', 10)
        accelerations = features.get('accelerations_count', 0)
        decelerations = features.get('decelerations_count', 0)
        deep_decels = features.get('deep_decelerations_count', 0)
        prolonged_decels = features.get('prolonged_decelerations', 0)
        
        if baseline < 100:
            risk_score += 0.8
            risk_factors.append(f"Критическая брадикардия: {baseline:.0f} bpm")
        elif baseline < 110:
            risk_score += 0.5
            risk_factors.append(f"Брадикардия: {baseline:.0f} bpm")
        if baseline > 170:
            risk_score += 0.7
            risk_factors.append(f"Выраженная тахикардия: {baseline:.0f} bpm")
        elif baseline > 160:
            risk_score += 0.4
            risk_factors.append(f"Тахикардия: {baseline:.0f} bpm")
        if variability < 2:
            risk_score += 0.7
            risk_factors.append(f"Критически низкая вариабельность: {variability:.1f} bpm")
        elif variability < 3:
            risk_score += 0.5
            risk_factors.append(f"Сниженная вариабельность: {variability:.1f} bpm")
        elif variability < 5:
            risk_score += 0.3
            risk_factors.append(f"Пограничная вариабельность: {variability:.1f} bpm")
        if accelerations == 0:
            risk_score += 0.4
            risk_factors.append("Отсутствие акселераций")
        if decelerations >= 3:
            risk_score += 0.5
            risk_factors.append(f"Множественные децелерации: {decelerations}")
        elif decelerations >= 1:
            risk_score += 0.3
            risk_factors.append(f"Децелерации: {decelerations}")
        if deep_decels > 0:
            risk_score += 0.5
            risk_factors.append(f"Глубокие децелерации: {deep_decels}")
        if prolonged_decels > 0:
            risk_score += 0.6
            risk_factors.append(f"Пролонгированные децелерации: {prolonged_decels}")
        
        probability = min(1.0, risk_score)
        risk_level = "CRITICAL" if probability > 0.6 else "HIGH" if probability > 0.4 else "MODERATE" if probability > 0.2 else "LOW"
        
        if risk_factors:
            self.logger.warning(f"Обнаружены факторы риска: {'; '.join(risk_factors)}")
        
        return {
            'hypoxia_probability': probability,
            'risk_level': risk_level,
            'confidence': 0.85,
            'method': 'expert_rules',
            'risk_factors': risk_factors
        }
    
    def _calculate_fwbs(self, fischer_result: Dict, ml_result: Dict, trend_result: Dict, signal_quality: float, clinical_risks: int) -> float:
        fwbs = 100.0
        rule_weight = 0.7 if ml_result['method'] == 'expert_rules' else 0.6
        fischer_weight = 0.3 if ml_result['method'] == 'expert_rules' else 0.2
        
        fischer_penalty = (10 - fischer_result['total_score']) * 2
        fwbs -= fischer_penalty * fischer_weight
        ml_penalty = ml_result['hypoxia_probability'] * 100
        fwbs -= ml_penalty * rule_weight
        if trend_result['status'] != 'insufficient_data':
            trend_penalty = trend_result.get('trend_score', 0) * 40
            fwbs -= trend_penalty * 0.2
        if 'risk_factors' in ml_result:
            for factor in ml_result['risk_factors']:
                if 'Критическая' in factor:
                    fwbs -= 20
                elif 'Выраженная' in factor:
                    fwbs -= 15
                elif 'Сниженная вариабельность' in factor:
                    fwbs -= 10
        if signal_quality < 0.5:
            fwbs -= 10
        elif signal_quality < 0.7:
            fwbs -= 5
        fwbs -= clinical_risks * 3
        return max(0, min(100, fwbs))
    
    def _determine_priority(self, fwbs: float) -> Tuple[str, int, str]:
        if fwbs >= 80:
            return ("NORMAL", 1, "Продолжить стандартное наблюдение")
        elif fwbs >= 65:
            return ("ATTENTION", 2, "Усилить наблюдение, повторная оценка через 5 минут")
        elif fwbs >= 50:
            return ("WARNING", 3, "Требуется осмотр врача в течение 10 минут")
        elif fwbs >= 35:
            return ("URGENT", 4, "Немедленный осмотр врача")
        else:
            return ("CRITICAL", 5, "Экстренное вмешательство")
    
    def _detect_clinical_patterns(self, features: Dict, signal_quality: float, 
                                  start_time: datetime = None) -> List[Dict]:
        """
        Обнаружение клинических паттернов с временными метками
        """
        patterns = []
        current_time = start_time if start_time else datetime.now()
        
        if features.get('prolonged_decelerations', 0) > 0:
            patterns.append({
                'type': 'prolonged_deceleration',
                'severity': 'high',
                'count': features['prolonged_decelerations'],
                'detected_at': current_time.isoformat(),
                'detected_at_readable': current_time.strftime('%H:%M:%S'),
                'clinical_significance': 'Требует немедленного внимания'
            })
        
        if features.get('deep_decelerations_count', 0) > 1:
            patterns.append({
                'type': 'repeated_deep_decelerations',
                'severity': 'high',
                'count': features['deep_decelerations_count'],
                'detected_at': current_time.isoformat(),
                'detected_at_readable': current_time.strftime('%H:%M:%S'),
                'clinical_significance': 'Возможная компрессия пуповины'
            })
        
        variability = features.get('variability', 10)
        if variability < 4:
            patterns.append({
                'type': 'reduced_variability',
                'severity': 'high' if variability < 2 else 'moderate',
                'value': variability,
                'detected_at': current_time.isoformat(),
                'detected_at_readable': current_time.strftime('%H:%M:%S'),
                'clinical_significance': 'Возможное угнетение ЦНС плода'
            })
        
        if features.get('accelerations_count', 0) == 0:
            patterns.append({
                'type': 'absent_accelerations',
                'severity': 'moderate',
                'detected_at': current_time.isoformat(),
                'detected_at_readable': current_time.strftime('%H:%M:%S'),
                'clinical_significance': 'Снижение реактивности плода'
            })
        
        baseline = features.get('baseline_bpm', 140)
        if baseline < 110 and baseline > 0:
            patterns.append({
                'type': 'bradycardia',
                'severity': 'high' if baseline < 100 else 'moderate',
                'value': baseline,
                'detected_at': current_time.isoformat(),
                'detected_at_readable': current_time.strftime('%H:%M:%S'),
                'clinical_significance': 'Возможная гипоксия'
            })
        
        if baseline > 160:
            patterns.append({
                'type': 'tachycardia',
                'severity': 'high' if baseline > 170 else 'moderate',
                'value': baseline,
                'detected_at': current_time.isoformat(),
                'detected_at_readable': current_time.strftime('%H:%M:%S'),
                'clinical_significance': 'Возможная инфекция или гипоксия'
            })
        
        if signal_quality < 0.6:
            patterns.append({
                'type': 'poor_signal_quality',
                'severity': 'low',
                'value': signal_quality,
                'detected_at': current_time.isoformat(),
                'detected_at_readable': current_time.strftime('%H:%M:%S'),
                'clinical_significance': 'Требуется переустановка датчиков'
            })
        
        return patterns
    
    def get_graph_data(self, fhr_4hz: np.ndarray, baseline: float, 
                      start_time: datetime = None) -> Dict[str, Any]:
        """
        Подготовка данных для графика с детальными временными метками
        """
        if start_time is None:
            start_time = datetime.now()
        
        timestamps = [(start_time + timedelta(seconds=i * 0.25)).isoformat() 
                     for i in range(len(fhr_4hz))]
        
        brady_threshold = 110
        tachy_threshold = 160
        severe_tachy_threshold = 170
        accel_threshold = baseline + 15
        decel_threshold = baseline - 15
        deep_decel_threshold = baseline - 30
        
        anomaly_zones = []
        current_anomaly = None
        anomaly_start_idx = None
        anomaly_severity = None
        
        for i, value in enumerate(fhr_4hz):
            anomaly_type = None
            severity = None
            
            if value == 0 or value < 50 or value > 210:
                anomaly_type = 'signal_loss'
                severity = 'warning'
            elif value < brady_threshold:
                anomaly_type = 'bradycardia'
                severity = 'critical' if value < 100 else 'high'
            elif value > severe_tachy_threshold:
                anomaly_type = 'severe_tachycardia'
                severity = 'critical'
            elif value > tachy_threshold:
                anomaly_type = 'tachycardia'
                severity = 'high'
            elif value > accel_threshold:
                anomaly_type = 'acceleration'
                severity = 'good'
            elif value < deep_decel_threshold:
                anomaly_type = 'deep_deceleration'
                severity = 'critical'
            elif value < decel_threshold:
                anomaly_type = 'deceleration'
                severity = 'high'
            
            if anomaly_type != current_anomaly:
                if current_anomaly is not None and anomaly_start_idx is not None:
                    end_idx = i - 1
                    duration_seconds = (end_idx - anomaly_start_idx + 1) * 0.25
                    
                    if duration_seconds >= 1.0:
                        zone_start_time = start_time + timedelta(seconds=anomaly_start_idx * 0.25)
                        zone_end_time = start_time + timedelta(seconds=end_idx * 0.25)
                        
                        anomaly_zones.append({
                            'type': current_anomaly,
                            'severity': anomaly_severity,
                            'start_time': zone_start_time.isoformat(),
                            'end_time': zone_end_time.isoformat(),
                            'start_time_readable': zone_start_time.strftime('%H:%M:%S'),
                            'end_time_readable': zone_end_time.strftime('%H:%M:%S'),
                            'start_index': anomaly_start_idx,
                            'end_index': end_idx,
                            'duration_seconds': round(duration_seconds, 1),
                            'min_value': float(np.min(fhr_4hz[anomaly_start_idx:end_idx+1])),
                            'max_value': float(np.max(fhr_4hz[anomaly_start_idx:end_idx+1])),
                            'color': self._get_anomaly_color(current_anomaly, anomaly_severity)
                        })
                
                if anomaly_type is not None:
                    current_anomaly = anomaly_type
                    anomaly_severity = severity
                    anomaly_start_idx = i
                else:
                    current_anomaly = None
                    anomaly_start_idx = None
                    anomaly_severity = None
        
        if current_anomaly is not None and anomaly_start_idx is not None:
            end_idx = len(fhr_4hz) - 1
            duration_seconds = (end_idx - anomaly_start_idx + 1) * 0.25
            
            if duration_seconds >= 1.0:
                zone_start_time = start_time + timedelta(seconds=anomaly_start_idx * 0.25)
                zone_end_time = start_time + timedelta(seconds=end_idx * 0.25)
                
                anomaly_zones.append({
                    'type': current_anomaly,
                    'severity': anomaly_severity,
                    'start_time': zone_start_time.isoformat(),
                    'end_time': zone_end_time.isoformat(),
                    'start_time_readable': zone_start_time.strftime('%H:%M:%S'),
                    'end_time_readable': zone_end_time.strftime('%H:%M:%S'),
                    'start_index': anomaly_start_idx,
                    'end_index': end_idx,
                    'duration_seconds': round(duration_seconds, 1),
                    'min_value': float(np.min(fhr_4hz[anomaly_start_idx:end_idx+1])),
                    'max_value': float(np.max(fhr_4hz[anomaly_start_idx:end_idx+1])),
                    'color': self._get_anomaly_color(current_anomaly, anomaly_severity)
                })
        
        anomaly_stats = {}
        for zone in anomaly_zones:
            zone_type = zone['type']
            if zone_type not in anomaly_stats:
                anomaly_stats[zone_type] = {
                    'count': 0,
                    'total_duration': 0,
                    'episodes': []
                }
            anomaly_stats[zone_type]['count'] += 1
            anomaly_stats[zone_type]['total_duration'] += zone['duration_seconds']
            anomaly_stats[zone_type]['episodes'].append({
                'time': f"{zone['start_time_readable']} - {zone['end_time_readable']}",
                'duration': f"{zone['duration_seconds']} сек",
                'severity': zone['severity'],
                'values': f"{zone['min_value']:.0f}-{zone['max_value']:.0f} bpm"
            })
        
        return {
            'timestamps': timestamps,
            'fhr_values': fhr_4hz.tolist(),
            'baseline': baseline,
            'normal_range': {'min': 110, 'max': 160},
            'anomaly_zones': anomaly_zones,
            'anomaly_statistics': anomaly_stats,
            'total_duration_seconds': len(fhr_4hz) * 0.25,
            'sampling_rate': 4,
            'analysis_period': {
                'start': start_time.isoformat(),
                'end': (start_time + timedelta(seconds=len(fhr_4hz) * 0.25)).isoformat(),
                'start_readable': start_time.strftime('%Y-%m-%d %H:%M:%S'),
                'end_readable': (start_time + timedelta(seconds=len(fhr_4hz) * 0.25)).strftime('%H:%M:%S')
            }
        }
    
    def _get_anomaly_color(self, anomaly_type: str, severity: str) -> str:
        colors = {
            'acceleration': '#00ff00',
            'normal': '#90ee90',
            'deceleration': '#ff6b6b',
            'deep_deceleration': '#cc0000',
            'bradycardia': '#800020',
            'tachycardia': '#ff9500',
            'severe_tachycardia': '#ff4500',
            'signal_loss': '#808080',
            'unknown': '#ffff00'
        }
        return colors.get(anomaly_type, '#ffff00')
    
    async def analyze(self, timeseries_data: pd.DataFrame = None, 
                     clinical_data: Optional[Dict[str, Any]] = None, 
                     include_graph_data: bool = False) -> Dict[str, Any]:
        """
        Главный метод анализа с исправленным расчетом времени
        """
        # Фиксируем время начала анализа
        analysis_start_time = datetime.now()

        # Получение данных
        if timeseries_data is None:
            timeseries_data = await self.get_data_from_db(limit=600)
        
        if timeseries_data is None or len(timeseries_data) < 15:
            return {
                'type': 'analysis_update',
                'error': True,
                'message': 'Недостаточно данных для анализа',
                'fetal_wellbeing_index': 0,
                'action_priority': 'ERROR',
                'timestamp': datetime.now().isoformat()
            }
        
        # Определяем время начала данных
        if 'timestamp' in timeseries_data.columns:
            data_start_time = pd.to_datetime(timeseries_data.iloc[0]['timestamp'])
        elif 'ts' in timeseries_data.columns:
            data_start_time = datetime.fromtimestamp(timeseries_data.iloc[0]['ts'])
        else:
            data_start_time = datetime.now() - timedelta(seconds=len(timeseries_data))
        
        # Интерполяция данных
        if 'fhr' in timeseries_data.columns:
            fhr_1hz = timeseries_data['fhr'].values
            uc_1hz = timeseries_data['uc'].values if 'uc' in timeseries_data else np.zeros_like(fhr_1hz)
            fhr_4hz = self.feature_extractor.interpolate_signal(fhr_1hz)
            uc_4hz = self.feature_extractor.interpolate_signal(uc_1hz)
            self.logger.info(f"Data interpolated: {len(fhr_1hz)} samples @ 1Hz -> {len(fhr_4hz)} samples @ 4Hz")
        else:
            return {
                'type': 'analysis_update',
                'error': True,
                'message': 'Неверный формат данных',
                'fetal_wellbeing_index': 0,
                'action_priority': 'ERROR',
                'timestamp': datetime.now().isoformat()
            }
        
        # Извлечение признаков
        if len(fhr_4hz) >= LONG_WINDOW_SAMPLES:
            fhr_long = fhr_4hz[-LONG_WINDOW_SAMPLES:]
            uc_long = uc_4hz[-LONG_WINDOW_SAMPLES:]
            features_long = self.feature_extractor.extract_features(fhr_long, uc_long, 'long')
            trend_df = pd.DataFrame({'fhr': fhr_long})
            trend_result = self.trend_analyzer.analyze(trend_df)
        else:
            features_long = self.feature_extractor.extract_features(fhr_4hz, uc_4hz, 'short')
            trend_result = {
                'status': 'insufficient_data',
                'description': 'Недостаточно данных для тренда',
                'confidence': 0.0,
                'trend_score': 0.1,
                'baseline_change': 0,
                'recent_change': 0
            }
        
        if len(fhr_4hz) >= SHORT_WINDOW_SAMPLES:
            fhr_short = fhr_4hz[-SHORT_WINDOW_SAMPLES:]
            uc_short = uc_4hz[-SHORT_WINDOW_SAMPLES:]
            features_short = self.feature_extractor.extract_features(fhr_short, uc_short, 'short')
        else:
            features_short = features_long
        
        # Анализ
        fischer_result = self.fischer_calculator.calculate(features_long)
        ml_result = self._predict_with_ml(features_long)
        clinical_risks = len(clinical_data.get('risk_factors', [])) if clinical_data else 0
        signal_quality = 1.0 - features_long.get('signal_loss_ratio', 0)
        detected_patterns = self._detect_clinical_patterns(features_short, signal_quality, data_start_time)
        
        # Расчет весов для FWBS
        rule_weight = 0.7 if ml_result['method'] == 'expert_rules' else 0.6
        fischer_weight = 0.3 if ml_result['method'] == 'expert_rules' else 0.2
        
        # Расчет FWBS и приоритета
        fwbs = self._calculate_fwbs(fischer_result, ml_result, trend_result, signal_quality, clinical_risks)
        action_priority, urgency_level, recommendation = self._determine_priority(fwbs)
        
        # Подготовка данных графика
        graph_data = None
        if include_graph_data and len(fhr_4hz) > 0:
            graph_data = self.get_graph_data(fhr_4hz, features_long['baseline_bpm'], data_start_time)
        
        # Правильный расчет времени обработки
        processing_time_seconds = (datetime.now() - analysis_start_time).total_seconds()
        
        # Формирование результата
        result = {
            'type': 'analysis_update',
            'fetal_wellbeing_index': round(fwbs, 1),
            'action_priority': action_priority,
            'urgency_level': urgency_level,
            'recommendation': recommendation,
            'expert_assessments': {
                'fischer': {
                    'total_score': fischer_result['total_score'],
                    'max_score': fischer_result['max_score'],
                    'interpretation': fischer_result['interpretation'],
                    'risk_category': fischer_result['risk_category'],
                    'weight_in_fwbs': f'{fischer_weight*100:.0f}%',
                    'components': fischer_result['detailed_scores']
                },
                'ml_model': {
                    'hypoxia_probability': round(ml_result['hypoxia_probability'], 3),
                    'risk_level': ml_result['risk_level'],
                    'confidence': round(ml_result['confidence'], 2),
                    'method': ml_result['method'],
                    'weight_in_fwbs': f'{rule_weight*100:.0f}%',
                    'model_available': self.model_available,
                    'risk_factors': ml_result.get('risk_factors', [])
                },
                'trend': {
                    'status': trend_result['status'],
                    'description': trend_result['description'],
                    'confidence': round(trend_result['confidence'], 2),
                    'baseline_change': round(trend_result.get('baseline_change', 0), 1),
                    'weight_in_fwbs': '20%'
                }
            },
            'key_metrics': {
                'baseline_fhr': round(features_long['baseline_bpm'], 1),
                'variability': round(features_long['variability'], 1),
                'accelerations': features_short.get('accelerations_count', 0),
                'decelerations': features_short.get('decelerations_count', 0),
                'deep_decelerations': features_short.get('deep_decelerations_count', 0),
                'prolonged_decelerations': features_short.get('prolonged_decelerations', 0),
                'signal_quality': round(signal_quality, 2),
                'signal_loss_ratio': round(features_long.get('signal_loss_ratio', 0), 3)
            },
            'detected_patterns': detected_patterns,
            'detected_patterns_count': len(detected_patterns),
            'metadata': {
                'analysis_timestamp': datetime.now().isoformat(),
                'analysis_timestamp_readable': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'service_version': self.version,
                'analysis_window_minutes': len(fhr_4hz) / (TARGET_SAMPLING_RATE * 60),
                'processing_time_ms': round(processing_time_seconds * 1000, 1),
                'clinical_risk_factors_count': clinical_risks,
                'data_source': 'realtime' if timeseries_data is None else 'provided',
                'data_period': {
                    'start': data_start_time.isoformat(),
                    'end': (data_start_time + timedelta(seconds=len(fhr_1hz))).isoformat(),
                    'start_readable': data_start_time.strftime('%Y-%m-%d %H:%M:%S'),
                    'end_readable': (data_start_time + timedelta(seconds=len(fhr_1hz))).strftime('%Y-%m-%d %H:%M:%S'),
                    'duration_seconds': len(fhr_1hz)
                }
            },
            'fischer_score': fischer_result['total_score'],
            'ml_probability': round(ml_result['hypoxia_probability'], 3),
            'trend_status': trend_result['status'],
            'baseline_fhr': round(features_long['baseline_bpm'], 1),
            'variability': round(features_long['variability'], 1),
            'accelerations': features_short.get('accelerations_count', 0),
            'decelerations': features_short.get('decelerations_count', 0),
            'signal_quality': round(signal_quality, 2)
        }
        
        # Добавляем данные графика
        if graph_data:
            result['graph_data'] = graph_data
            
            # Добавляем сводку по времени аномалий
            if graph_data['anomaly_zones']:
                result['anomaly_timeline'] = []
                for zone in graph_data['anomaly_zones']:
                    result['anomaly_timeline'].append({
                        'type': zone['type'],
                        'severity': zone['severity'],
                        'time_range': f"{zone['start_time_readable']} - {zone['end_time_readable']}",
                        'duration': f"{zone['duration_seconds']} сек",
                        'values': f"{zone['min_value']:.0f}-{zone['max_value']:.0f} bpm"
                    })
        
        # Сохранение результата
        self.last_analysis_result = result
        self.analysis_history.append({
            'timestamp': datetime.now().isoformat(),
            'fwbs': result['fetal_wellbeing_index'],
            'priority': result['action_priority']
        })
        if len(self.analysis_history) > 100:
            self.analysis_history.pop(0)
        
        await self.save_analysis_result(result)
        self.logger.info(f"Analysis completed in {processing_time_seconds:.3f}s: FWBS={fwbs:.1f}, Priority={action_priority}")
        return result
    
    async def start_analysis_loop(self, websocket_callback=None):
        self.logger.info(f"Starting analysis loop (interval: {ANALYSIS_INTERVAL_SECONDS}s)")
        while True:
            try:
                result = await self.analyze(include_graph_data=True)
                if websocket_callback and not result.get('error'):
                    await websocket_callback(result)
                if result.get('action_priority') in ['CRITICAL', 'URGENT']:
                    self.logger.warning(f"⚠️ CRITICAL STATE DETECTED: {result.get('action_priority')}")
                    self.logger.warning(f"   Recommendation: {result.get('recommendation')}")
            except Exception as e:
                self.logger.error(f"Error in analysis loop: {e}")
            await asyncio.sleep(ANALYSIS_INTERVAL_SECONDS)

# ============================================================================
# ТЕСТОВЫЙ БЛОК
# ============================================================================
if __name__ == "__main__":
    async def test_service():
        print("\n" + "="*80)
        print("🏥 FINAL PREDICTION SERVICE v2.2 - Real-time CTG Analysis with Timeline")
        print("="*80)
        print("\n📦 Инициализация сервиса...")
        service = PredictionService(model_path="ml_model.pkl")
        
        print("\n📊 Генерация тестовых данных (1 Гц)...")
        n_samples_1hz = 60
        baseline = 140
        fhr_1hz = np.full(n_samples_1hz, baseline, dtype=float) + np.random.normal(0, 4, n_samples_1hz)
        fhr_1hz[30:40] += 20  # Акселерация
        fhr_1hz[45:50] -= 25  # Децелерация
        uc_1hz = np.random.uniform(10, 30, n_samples_1hz)
        fhr_1hz = np.clip(fhr_1hz, 50, 210)
        uc_1hz = np.clip(uc_1hz, 0, 100)
        
        # Создаем DataFrame с временными метками
        start_time = datetime.now() - timedelta(seconds=n_samples_1hz)
        test_data = pd.DataFrame({
            'fhr': fhr_1hz,
            'uc': uc_1hz,
            'timestamp': pd.date_range(start=start_time, periods=n_samples_1hz, freq='1s')
        })
        
        print(f"✅ Тестовые данные готовы")
        print(f"   • Длительность: {n_samples_1hz} секунд")
        print(f"   • Частота: 1 Гц")
        print(f"   • Baseline: ~{baseline} bpm")
        print(f"   • Акселерация: 30-40 сек")
        print(f"   • Децелерация: 45-50 сек")
        
        print("\n🔬 Запуск анализа...")
        result = await service.analyze(test_data, include_graph_data=True)
        
        if not result.get('error'):
            print("\n" + "="*80)
            print("📈 РЕЗУЛЬТАТЫ АНАЛИЗА")
            print("="*80)
            print(f"\n🎯 ГЛАВНЫЕ ПОКАЗАТЕЛИ:")
            print(f"   • Type: {result['type']}")
            print(f"   • FWBS: {result['fetal_wellbeing_index']}/100")
            print(f"   • Приоритет: {result['action_priority']}")
            print(f"   • Срочность: {result['urgency_level']}/5")
            print(f"   • Рекомендация: {result['recommendation']}")
            
            print(f"\n💓 МЕТРИКИ:")
            metrics = result['key_metrics']
            print(f"   • Baseline: {metrics['baseline_fhr']} bpm")
            print(f"   • Вариабельность: {metrics['variability']} bpm")
            print(f"   • Акселерации: {metrics['accelerations']}")
            print(f"   • Децелерации: {metrics['decelerations']}")
            print(f"   • Качество сигнала: {metrics['signal_quality']:.0%}")
            
            print(f"\n⚙️ МЕТАДАННЫЕ:")
            metadata = result['metadata']
            print(f"   • Время анализа: {metadata['analysis_timestamp_readable']}")
            print(f"   • Время обработки: {metadata['processing_time_ms']} мс")
            print(f"   • Окно анализа: {metadata['analysis_window_minutes']:.1f} минут")
            print(f"   • Период данных: {metadata['data_period']['start_readable']} - {metadata['data_period']['end_readable']}")
            
            if 'graph_data' in result:
                print(f"\n📊 ДАННЫЕ ГРАФИКА:")
                graph = result['graph_data']
                print(f"   • Период анализа: {graph['analysis_period']['start_readable']} - {graph['analysis_period']['end_readable']}")
                print(f"   • Длительность: {graph['total_duration_seconds']} сек")
                print(f"   • Обнаружено аномалий: {len(graph['anomaly_zones'])}")
                
                if graph['anomaly_zones']:
                    print(f"\n⏱️ ВРЕМЕННАЯ ШКАЛА АНОМАЛИЙ:")
                    for zone in graph['anomaly_zones']:
                        print(f"   • {zone['type'].upper()} ({zone['severity']})")
                        print(f"     Время: {zone['start_time_readable']} - {zone['end_time_readable']}")
                        print(f"     Длительность: {zone['duration_seconds']} сек")
                        print(f"     Значения: {zone['min_value']:.0f}-{zone['max_value']:.0f} bpm")
            
            if 'anomaly_timeline' in result:
                print(f"\n📅 СВОДКА АНОМАЛИЙ:")
                for anomaly in result['anomaly_timeline']:
                    print(f"   • {anomaly['type']}: {anomaly['time_range']} ({anomaly['duration']})")
                    print(f"     Диапазон значений: {anomaly['values']}")
            
            if 'detected_patterns' in result and result['detected_patterns']:
                print(f"\n🔍 ОБНАРУЖЕННЫЕ ПАТТЕРНЫ:")
                for pattern in result['detected_patterns']:
                    print(f"   • {pattern['type']} ({pattern['severity']})")
                    print(f"     Обнаружено в: {pattern.get('detected_at_readable', 'N/A')}")
                    print(f"     Значимость: {pattern['clinical_significance']}")
            
            print("\n" + "="*80)
            print("✅ Тест завершен успешно!")
        else:
            print(f"\n❌ Ошибка: {result['message']}")
        print("="*80)
    
    asyncio.run(test_service())


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\guardian_angel\db_manager.py
================================================================================

import sqlite3
import threading
import time
import os


class DBManager:
    def __init__(self, db_path=None, flush_interval_seconds=5, max_buffer=50):
        if db_path is None:
            db_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'guardian_angel_data.db')
        self.db_path = db_path
        self.flush_interval_seconds = flush_interval_seconds
        self.max_buffer = max_buffer
        self.buffer = []
        self.lock = threading.Lock()
        self._ensure_db()
        self.stop_event = threading.Event()
        self.thread = threading.Thread(target=self._flusher, daemon=True)
        self.thread.start()

    def _ensure_db(self):
        dirpath = os.path.dirname(self.db_path) or '.'
        os.makedirs(dirpath, exist_ok=True)
        conn = self.get_conn()
        try:
            cur = conn.cursor()
            cur.execute('''
            CREATE TABLE IF NOT EXISTS ctg_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ts INTEGER,
                bpm_time REAL,
                bpm_value REAL,
                uterus_time REAL,
                uterus_value REAL
            )
            ''')
            conn.commit()
        finally:
            conn.close()

    def add(self, ts, bpm_time, bpm_value, uterus_time, uterus_value):
        with self.lock:
            self.buffer.append((ts, bpm_time, bpm_value, uterus_time, uterus_value))
            if len(self.buffer) >= self.max_buffer:
                self._flush()

    def get(self, limit=50):
        conn = self.get_conn()
        cur = conn.cursor()
        cur.execute(
            "SELECT id, ts, bpm_time, bpm_value, uterus_time, uterus_value FROM ctg_data ORDER BY id DESC LIMIT ?",
            (limit,))
        rows = cur.fetchall()
        conn.close()
        return rows

    def get_conn(self):
        return sqlite3.connect(self.db_path, timeout=10)

    def _flush(self):
        with self.lock:
            if not self.buffer:
                return
            data_to_write = self.buffer[:]
            self.buffer.clear()
        conn = self.get_conn()
        try:
            cur = conn.cursor()
            cur.executemany(
                "INSERT INTO ctg_data (ts, bpm_time, bpm_value, uterus_time, uterus_value) VALUES (?, ?, ?, ?, ?)",
                data_to_write
            )
            conn.commit()
        finally:
            conn.close()

    def _flusher(self):
        while not self.stop_event.is_set():
            time.sleep(self.flush_interval_seconds)
            self._flush()

    def stop(self):
        self.stop_event.set()
        self._flush()


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\guardian_angel\client_main.py
================================================================================

# client_main.py
import json
import socket
import time
import os
import sys
import asyncio
import websockets

sys.path.append(os.path.dirname(__file__))
from db_manager import DBManager

HOST = '127.0.0.1'
PORT = 65432

def safe_int(x, fallback=None):
    try:
        return int(float(x))
    except Exception:
        return fallback

def safe_float(x, fallback=None):
    try:
        return float(x)
    except Exception:
        return fallback

# WebSocket клиент для отправки данных в API
class WebSocketClient:
    def __init__(self):
        self.websocket = None
        self.is_connected = False
        
    async def connect(self):
        try:
            self.websocket = await websockets.connect('ws://localhost:8000/ws')
            self.is_connected = True
            print("✅ WebSocket connected to API")
            
            # Слушаем сообщения от сервера
            asyncio.create_task(self.listen_messages())
            
        except Exception as e:
            print(f"❌ WebSocket connection failed: {e}")
            self.is_connected = False
            
    async def listen_messages(self):
        try:
            async for message in self.websocket:
                data = json.loads(message)
                if data.get("type") == "pong":
                    print("🏓 Received pong from server")
                elif data.get("type") == "connection":
                    print(f"🔗 {data.get('message')}")
        except Exception as e:
            print(f"Error in WebSocket listener: {e}")
            self.is_connected = False
            
    async def send_data(self, data):
        if self.is_connected and self.websocket:
            try:
                await self.websocket.send(json.dumps(data))
                return True
            except Exception as e:
                print(f"Error sending WebSocket data: {e}")
                self.is_connected = False
                return False
        return False
        
    async def close(self):
        if self.websocket:
            await self.websocket.close()
            self.is_connected = False

# Глобальный WebSocket клиент
ws_client = WebSocketClient()

async def start_receive():
    db = DBManager()
    
    # Подключаемся к WebSocket
    await ws_client.connect()
    
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((HOST, PORT))
        buffer = ''
        print(f"✅ Connected to data server {HOST}:{PORT}")
        
        while True:
            data = s.recv(4096)
            if not data:
                print("❌ Connection closed by server")
                break
                
            buffer += data.decode('utf-8', errors='ignore')
            while '\n' in buffer:
                line, buffer = buffer.split('\n', 1)
                if not line.strip():
                    continue
                    
                try:
                    data_json = json.loads(line)
                    ts = int(time.time())
                    
                    # Извлекаем данные ЧСС и СДМ
                    bpm = data_json.get('bpm', [None, None])
                    uterus = data_json.get('uterus', [None, None])
                    
                    bpm_time = safe_float(bpm[0], fallback=None)
                    bpm_value = safe_float(bpm[1], fallback=None)
                    uterus_time = safe_float(uterus[0], fallback=None)
                    uterus_value = safe_float(uterus[1], fallback=None)
                    
                    # Сохраняем в базу данных
                    db.add(ts, bpm_time, bpm_value, uterus_time, uterus_value)
                    
                    # Подготавливаем данные для WebSocket
                    ws_data = {
                        "type": "ctg_data",
                        "ts": ts,
                        "bpm_value": bpm_value,
                        "uterus_value": uterus_value,
                        "bpm_time": bpm_time,
                        "uterus_time": uterus_time
                    }
                    
                    # Отправляем через WebSocket
                    success = await ws_client.send_data(ws_data)
                    
                    if success:
                        print(f"📨 Sent: FHR={bpm_value}, UA={uterus_value}")
                    else:
                        print(f"💾 Saved: FHR={bpm_value}, UA={uterus_value} (WebSocket offline)")
                        
                except json.JSONDecodeError as e:
                    print(f"❌ JSON decode error: {e}")
                    print(f"Raw data: {line}")
                except Exception as e:
                    print(f"❌ Error processing message: {e}")

async def main():
    try:
        print("🚀 Starting CTG Data Receiver with WebSocket...")
        print("📡 Connecting to:")
        print(f"   • Data Server: {HOST}:{PORT}")
        print(f"   • WebSocket API: ws://localhost:8000/ws")
        print(f"   • Database: {os.path.join(os.getcwd(), 'guardian_angel_data.db')}")
        
        await start_receive()
        
    except KeyboardInterrupt:
        print("\n🛑 Stopping receiver...")
    except Exception as e:
        print(f"❌ Fatal error: {e}")
    finally:
        await ws_client.close()
        print("👋 Receiver stopped")

if __name__ == '__main__':
    # Запускаем асинхронный main
    asyncio.run(main())


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\guardian_angel\api.py
================================================================================

"""
Guardian Angel API v4.2
Real-time backend for CTG monitoring system with MIS integration
"""

import sys
import csv
import os
import time
import asyncio
import json
import logging
import httpx
import glob
from pathlib import Path
from typing import List, Optional, Dict, Any
from datetime import datetime
from contextlib import asynccontextmanager

from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException
from fastapi.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field

# Относительные импорты для модулей в том же пакете
from db_manager import DBManager
from final_prediction_service import PredictionService

# ==================== НАСТРОЙКА ЛОГИРОВАНИЯ ====================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    encoding='utf-8'
)
logger = logging.getLogger(__name__)

# ==================== КОНСТАНТЫ ====================
DB_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'guardian_angel_data.db')
EMULATOR_HOST = 'localhost'
EMULATOR_PORT = 65432
RECONNECT_DELAY = 5  # секунд между попытками переподключения
PREDICTION_INTERVAL = 10  # секунд между анализами
ARCHIVES_QUEUE_DIR = "archives_to_send"  # Папка для очереди архивов
ARCHIVE_SENDER_INTERVAL = 300  # Интервал проверки очереди (5 минут)
ARCHIVE_SEND_TIMEOUT = 30  # Таймаут отправки архива

# ==================== ХРАНИЛИЩЕ КЛИНИЧЕСКИХ ДАННЫХ (эмуляция МИС) ====================
# Словарь для хранения клинических данных пациентов
# Ключ: session_id, Значение: данные пациента
patient_clinical_data: Dict[str, dict] = {
    "default": {
        "risk_factors": [],
        "patient_name": "Не указано",
        "pregnancy_week": None
    }  # Сессия по умолчанию
}

# ==================== PYDANTIC МОДЕЛИ ====================

class ClinicalDataPayload(BaseModel):
    """Модель клинических данных пациента"""
    patient_name: Optional[str] = Field(None, description="ФИО пациента")
    risk_factors: List[str] = Field(default_factory=list, description="Список факторов риска")
    patient_age: Optional[int] = Field(None, ge=0, le=100, description="Возраст пациента")
    pregnancy_week: Optional[int] = Field(None, ge=0, le=45, description="Неделя беременности")
    previous_pregnancies: Optional[int] = Field(None, ge=0, description="Количество предыдущих беременностей")
    medications: Optional[List[str]] = Field(None, description="Принимаемые медикаменты")


class PatientInfo(BaseModel):
    """Полная информация о пациенте"""
    session_id: str
    patient_name: Optional[str] = None
    risk_factors: List[str]
    patient_age: Optional[int] = None
    pregnancy_week: Optional[int] = None
    previous_pregnancies: Optional[int] = None
    medications: Optional[List[str]] = None
    last_updated: Optional[str] = None

class SessionEndRequest(BaseModel):
    """Модель запроса для завершения сессии"""
    archive_server_url: str = Field(..., description="URL сервера для архивации данных")
    session_notes: Optional[str] = Field(None, description="Примечания к сессии")
    doctor_name: Optional[str] = Field(None, description="ФИО врача")

# ==================== WEBSOCKET MANAGER ====================

class ConnectionManager:
    """
    Менеджер WebSocket соединений.
    Управляет подключениями клиентов и рассылкой сообщений.
    """
    
    def __init__(self):
        self.active_connections: List[WebSocket] = []
        self.lock = asyncio.Lock()
    
    async def connect(self, websocket: WebSocket):
        """Принять новое WebSocket соединение"""
        await websocket.accept()
        async with self.lock:
            self.active_connections.append(websocket)
        logger.info(f"[CONNECTED] WebSocket клиент подключен. Активных подключений: {len(self.active_connections)}")
    
    async def disconnect(self, websocket: WebSocket):
        """Отключить WebSocket соединение"""
        async with self.lock:
            if websocket in self.active_connections:
                self.active_connections.remove(websocket)
        logger.info(f"[DISCONNECTED] WebSocket клиент отключен. Активных подключений: {len(self.active_connections)}")
    
    async def broadcast(self, message: dict):
        """Отправить сообщение всем подключенным клиентам"""
        if not self.active_connections:
            return
        
        # Сериализуем сообщение один раз
        try:
            json_message = json.dumps(message, default=str)
        except Exception as e:
            logger.error(f"Ошибка сериализации сообщения: {e}")
            return
        
        # Копируем список соединений для безопасной итерации
        async with self.lock:
            connections = self.active_connections.copy()
        
        # Отправляем всем клиентам и собираем отключенные соединения
        disconnected = []
        for connection in connections:
            try:
                await connection.send_text(json_message)
            except Exception as e:
                logger.warning(f"Не удалось отправить сообщение клиенту: {e}")
                disconnected.append(connection)
        
        # Удаляем отключенные соединения
        for connection in disconnected:
            await self.disconnect(connection)


# ==================== TCP CLIENT ДЛЯ ЭМУЛЯТОРА ====================

class EmulatorClient:
    """
    TCP клиент для подключения к эмулятору КТГ.
    Получает данные от эмулятора, сохраняет в БД и транслирует через WebSocket.
    """
    
    def __init__(self, manager: ConnectionManager, prediction_service: PredictionService):
        self.manager = manager
        self.prediction_service = prediction_service
        self.reader: Optional[asyncio.StreamReader] = None
        self.writer: Optional[asyncio.StreamWriter] = None
        self.running = False
        self.db = DBManager()
        self.last_prediction_time = time.time()
        self.prediction_interval = PREDICTION_INTERVAL
        self.current_session_id = "default"
        self.data_counter = 0  # Счетчик полученных данных для отладки
    
    async def connect(self) -> bool:
        """Установить соединение с эмулятором"""
        try:
            self.reader, self.writer = await asyncio.open_connection(
                EMULATOR_HOST, EMULATOR_PORT
            )
            logger.info(f"[SUCCESS] Успешно подключено к эмулятору {EMULATOR_HOST}:{EMULATOR_PORT}")
            
            # Уведомляем фронтенд о подключении
            await self.manager.broadcast({
                "type": "system",
                "message": "Connected to CTG device",
                "status": "connected"
            })
            return True
            
        except Exception as e:
            logger.error(f"[ERROR] Не удалось подключиться к эмулятору: {e}")
            await self.manager.broadcast({
                "type": "system",
                "message": f"Failed to connect to CTG device: {str(e)}",
                "status": "disconnected"
            })
            return False
    
    async def disconnect(self):
        """Закрыть соединение с эмулятором"""
        if self.writer:
            try:
                self.writer.close()
                await self.writer.wait_closed()
            except Exception as e:
                logger.error(f"Ошибка при закрытии соединения: {e}")
            finally:
                self.writer = None
                self.reader = None
                logger.info("[DISCONNECTED] Отключено от эмулятора")
    
    def safe_float_convert(self, value: Any, field_name: str) -> Optional[float]:
        """
        Безопасное преобразование значения в float.
        Логирует ошибки преобразования.
        """
        try:
            if isinstance(value, (int, float)):
                return float(value)
            elif isinstance(value, str):
                # Удаляем пробелы и заменяем запятую на точку
                cleaned = value.strip().replace(',', '.')
                return float(cleaned)
            else:
                logger.warning(f"Неожиданный тип данных для {field_name}: {type(value).__name__}")
                return None
        except (ValueError, TypeError) as e:
            logger.error(f"Не удалось преобразовать {field_name}='{value}' в число: {e}")
            return None
    
    async def process_data(self, data: dict):
        """
        Обработка данных от эмулятора.
        Ожидаемый формат: {"bpm": ["время", "значение"], "uterus": ["время", "значение"]}
        """
        try:
            self.data_counter += 1
            logger.debug(f"[DATA] Обработка данных #{self.data_counter}: {data}")
            
            # ===== 1. ВАЛИДАЦИЯ СТРУКТУРЫ ДАННЫХ =====
            if not isinstance(data, dict):
                logger.error(f"Получены данные неверного типа: {type(data).__name__}. Данные: {data}")
                return
            
            bpm_data = data.get('bpm')
            uterus_data = data.get('uterus')
            
            # Проверяем наличие обязательных полей
            if bpm_data is None or uterus_data is None:
                logger.error(f"Отсутствуют обязательные поля. Получено: {list(data.keys())}. Полные данные: {data}")
                return
            
            # Проверяем формат данных (должны быть списки из 2 элементов)
            if not isinstance(bpm_data, list) or len(bpm_data) < 2:
                logger.error(f"Неверный формат bpm_data: {bpm_data}")
                return
            
            if not isinstance(uterus_data, list) or len(uterus_data) < 2:
                logger.error(f"Неверный формат uterus_data: {uterus_data}")
                return
            
            # ===== 2. ИЗВЛЕЧЕНИЕ И ПРЕОБРАЗОВАНИЕ ДАННЫХ =====
            bpm_time_str = str(bpm_data[0])  # Время как строка
            bpm_value_raw = bpm_data[1]  # Значение (может быть строкой или числом)
            
            uterus_time_str = str(uterus_data[0])  # Время как строка
            uterus_value_raw = uterus_data[1]  # Значение (может быть строкой или числом)
            
            # Безопасное преобразование значений в float
            bpm_value = self.safe_float_convert(bpm_value_raw, "bpm_value")
            uterus_value = self.safe_float_convert(uterus_value_raw, "uterus_value")
            
            # Проверяем успешность преобразования
            if bpm_value is None or uterus_value is None:
                logger.error(f"Не удалось преобразовать значения в числа. Исходные данные: {data}")
                return
            
            # ===== 3. СОЗДАНИЕ ВРЕМЕННЫХ МЕТОК =====
            unix_timestamp = int(time.time())
            iso_timestamp = datetime.now().isoformat()
            
            # ===== 4. СОХРАНЕНИЕ В БАЗУ ДАННЫХ =====
            logger.debug(f"[DB] Сохранение в БД: ts={unix_timestamp}, bpm={bpm_value}, uterus={uterus_value}")
            
            # Используем правильный порядок аргументов для db.add()
            await asyncio.to_thread(
                self.db.add,
                unix_timestamp,      # ts (unix timestamp)
                bpm_time_str,       # bpm_time (строка времени от эмулятора)
                bpm_value,          # bpm_value (числовое значение)
                uterus_time_str,    # uterus_time (строка времени от эмулятора)
                uterus_value        # uterus_value (числовое значение)
            )
            
            logger.info(f"[SAVED] Данные сохранены: BPM={bpm_value:.1f}, Uterus={uterus_value:.1f}")
            
            # ===== 5. ОТПРАВКА ЧЕРЕЗ WEBSOCKET =====
            ws_message = {
                "type": "ctg_data",
                "data": {
                    "timestamp": iso_timestamp,
                    "session_id": self.current_session_id,
                    "bpm_time": bpm_time_str,
                    "bpm_value": bpm_value,
                    "uterus_time": uterus_time_str,
                    "uterus_value": uterus_value,
                    "data_point": self.data_counter  # Для отладки на фронтенде
                }
            }
            
            await self.manager.broadcast(ws_message)
            
            # ===== 6. ПЕРИОДИЧЕСКИЙ ЗАПУСК АНАЛИЗА =====
            current_time = time.time()
            if current_time - self.last_prediction_time >= self.prediction_interval:
                self.last_prediction_time = current_time
                logger.info("[ANALYSIS] Запуск периодического анализа...")
                await self.run_prediction_analysis(self.current_session_id)
            
        except Exception as e:
            logger.error(f"[CRITICAL] Критическая ошибка в process_data. Данные: {data}. Ошибка: {e}", exc_info=True)
    
    async def run_prediction_analysis(self, session_id: str = "default"):
        """Запуск ML-анализа с учетом клинических данных"""
        try:
            # Получаем клинические данные пациента
            clinical_data = patient_clinical_data.get(session_id)
            
            if clinical_data and clinical_data.get('risk_factors'):
                logger.info(f"[ANALYSIS] Анализ с учетом факторов риска: {clinical_data['risk_factors']}")
            
            # Запускаем анализ
            result = await self.prediction_service.analyze(
                clinical_data=clinical_data,
                include_graph_data=False  # График не включаем в периодический анализ
            )
            
            # Добавляем информацию о клинических данных
            result['clinical_data_applied'] = bool(clinical_data and clinical_data.get('risk_factors'))
            result['risk_factors'] = clinical_data.get('risk_factors', []) if clinical_data else []
            result['session_id'] = session_id
            
            # Отправляем результат через WebSocket
            await self.manager.broadcast({
                "type": "prediction",
                "session_id": session_id,
                "data": result
            })
            
            # Логируем результат
            fwbs = result.get('fetal_wellbeing_index', 100)
            risk_level = result.get('risk_level', 'unknown')
            logger.info(f"[RESULT] Анализ завершен: FWBS={fwbs:.1f}, Risk={risk_level}")
            
            # Отправляем предупреждение при высоком риске
            if risk_level in ['high', 'critical'] or fwbs < 70:
                await self.manager.broadcast({
                    "type": "alert",
                    "severity": "high" if fwbs < 50 else "medium",
                    "message": f"[WARNING] Требуется внимание! Индекс благополучия: {fwbs:.1f}",
                    "session_id": session_id
                })
            
        except Exception as e:
            logger.error(f"[ERROR] Ошибка при выполнении анализа: {e}", exc_info=True)
    
    async def run(self):
        """Основной цикл работы клиента"""
        self.running = True
        logger.info("[START] Запуск EmulatorClient...")
        
        while self.running:
            try:
                # Пытаемся подключиться к эмулятору
                if not await self.connect():
                    logger.info(f"[RETRY] Повторная попытка через {RECONNECT_DELAY} секунд...")
                    await asyncio.sleep(RECONNECT_DELAY)
                    continue
                
                # Основной цикл чтения данных
                buffer = b""  # Буфер для неполных строк
                
                while self.running and self.reader:
                    try:
                        # Читаем данные из сокета с увеличенным таймаутом
                        chunk = await asyncio.wait_for(
                            self.reader.read(1024),
                            timeout=60.0  # Увеличенный таймаут
                        )
                        
                        if not chunk:
                            logger.warning("[EMPTY] Получен пустой chunk - соединение закрыто")
                            break
                        
                        # Добавляем к буферу
                        buffer += chunk
                        
                        # Обрабатываем полные строки
                        while b'\n' in buffer:
                            line, buffer = buffer.split(b'\n', 1)
                            if line:
                                try:
                                    json_str = line.decode('utf-8').strip()
                                    if json_str:
                                        json_data = json.loads(json_str)
                                        await self.process_data(json_data)
                                except json.JSONDecodeError as e:
                                    logger.error(f"[JSON ERROR] Ошибка парсинга JSON: {e}. Строка: {line[:100]}")
                                except UnicodeDecodeError as e:
                                    logger.error(f"[DECODE ERROR] Ошибка декодирования: {e}")
                    
                    except asyncio.TimeoutError:
                        logger.warning("[TIMEOUT] Таймаут чтения данных от эмулятора")
                        # Проверяем соединение
                        if self.writer:
                            try:
                                self.writer.write(b'\n')
                                await self.writer.drain()
                            except:
                                break
                    
                    except Exception as e:
                        logger.error(f"[READ ERROR] Ошибка при чтении данных: {e}")
                        break
                
                # Отключаемся перед переподключением
                await self.disconnect()
                
                if self.running:
                    logger.info(f"[RECONNECT] Переподключение через {RECONNECT_DELAY} секунд...")
                    await asyncio.sleep(RECONNECT_DELAY)
                    
            except Exception as e:
                logger.error(f"[CRITICAL] Критическая ошибка в главном цикле: {e}", exc_info=True)
                await asyncio.sleep(RECONNECT_DELAY)
    
    async def stop(self):
        """Остановка клиента"""
        logger.info("[STOP] Остановка EmulatorClient...")
        self.running = False
        await self.disconnect()


# ==================== ФОНОВЫЙ ПРОЦЕСС "ПОЧТАЛЬОН" ====================

async def archive_sender_worker():
    """
    Фоновый процесс для отправки архивов из локальной очереди.
    Работает постоянно, проверяя папку с неотправленными архивами.
    """
    logger.info("[ARCHIVE SENDER] Запуск фонового процесса отправки архивов")
    
    # Создаем папку для очереди, если её нет
    os.makedirs(ARCHIVES_QUEUE_DIR, exist_ok=True)
    
    while True:
        try:
            # Получаем список файлов в очереди
            archive_files = sorted(glob.glob(os.path.join(ARCHIVES_QUEUE_DIR, "*.json")))
            
            if archive_files:
                logger.info(f"[ARCHIVE SENDER] Найдено {len(archive_files)} архивов в очереди")
                
                for archive_path in archive_files:
                    try:
                        # Читаем архив
                        with open(archive_path, 'r', encoding='utf-8') as f:
                            archive_data = json.load(f)
                        
                        # Извлекаем URL сервера из метаданных
                        server_url = archive_data.get('metadata', {}).get('archive_server_url')
                        
                        if not server_url:
                            logger.error(f"[ARCHIVE SENDER] Отсутствует URL сервера в архиве {archive_path}")
                            # Перемещаем в папку с ошибками
                            error_dir = os.path.join(ARCHIVES_QUEUE_DIR, "errors")
                            os.makedirs(error_dir, exist_ok=True)
                            error_path = os.path.join(error_dir, os.path.basename(archive_path))
                            os.rename(archive_path, error_path)
                            continue
                        
                        # Подготавливаем данные для отправки (без URL в метаданных)
                        send_data = archive_data.copy()
                        if 'metadata' in send_data and 'archive_server_url' in send_data['metadata']:
                            del send_data['metadata']['archive_server_url']
                        
                        logger.info(f"[ARCHIVE SENDER] Попытка отправки архива {os.path.basename(archive_path)} на {server_url}")
                        
                        # Пытаемся отправить
                        async with httpx.AsyncClient(timeout=ARCHIVE_SEND_TIMEOUT) as client:
                            response = await client.post(
                                server_url,
                                json=send_data,
                                headers={"Content-Type": "application/json"}
                            )
                            
                            if response.status_code in [200, 201, 202]:
                                # Успешная отправка
                                logger.info(f"[ARCHIVE SENDER] ✅ Архив успешно отправлен: {os.path.basename(archive_path)}")
                                
                                # Перемещаем в папку успешно отправленных
                                sent_dir = os.path.join(ARCHIVES_QUEUE_DIR, "sent")
                                os.makedirs(sent_dir, exist_ok=True)
                                sent_path = os.path.join(sent_dir, os.path.basename(archive_path))
                                os.rename(archive_path, sent_path)
                                
                                # Уведомляем через WebSocket
                                await manager.broadcast({
                                    "type": "archive_sent",
                                    "session_id": archive_data.get("session_id"),
                                    "message": f"Архив сессии {archive_data.get('session_id')} успешно отправлен на сервер"
                                })
                            else:
                                logger.warning(f"[ARCHIVE SENDER] Сервер вернул код {response.status_code} для {os.path.basename(archive_path)}")
                                # Оставляем в очереди для повторной попытки
                                
                    except httpx.ConnectError:
                        logger.warning(f"[ARCHIVE SENDER] Нет соединения с сервером для {os.path.basename(archive_path)}")
                        # Файл остается в очереди
                    except httpx.TimeoutException:
                        logger.warning(f"[ARCHIVE SENDER] Таймаут при отправке {os.path.basename(archive_path)}")
                        # Файл остается в очереди
                    except Exception as e:
                        logger.error(f"[ARCHIVE SENDER] Ошибка при обработке {archive_path}: {e}", exc_info=True)
                        # Файл остается в очереди
                    
                    # Небольшая пауза между отправками
                    await asyncio.sleep(2)
            else:
                logger.debug("[ARCHIVE SENDER] Очередь архивов пуста")
            
        except Exception as e:
            logger.error(f"[ARCHIVE SENDER] Критическая ошибка в цикле отправки: {e}", exc_info=True)
        
        # Ждем перед следующей проверкой
        await asyncio.sleep(ARCHIVE_SENDER_INTERVAL)


# ==================== ИНИЦИАЛИЗАЦИЯ КОМПОНЕНТОВ ====================

manager = ConnectionManager()
prediction_service = PredictionService(model_path="ml_model.pkl")
emulator_client = EmulatorClient(manager, prediction_service)


# ==================== LIFESPAN MANAGEMENT ====================

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Управление жизненным циклом приложения"""
    logger.info("=" * 50)
    logger.info("[STARTUP] ЗАПУСК Guardian Angel API v4.2")
    logger.info(f"[DATABASE] База данных: {DB_PATH}")
    logger.info(f"[EMULATOR] Эмулятор: {EMULATOR_HOST}:{EMULATOR_PORT}")
    logger.info(f"[ARCHIVES] Папка очереди: {ARCHIVES_QUEUE_DIR}")
    logger.info("=" * 50)
    
    # Запускаем фоновые задачи
    emulator_task = asyncio.create_task(emulator_client.run())
    archive_sender_task = asyncio.create_task(archive_sender_worker())  # Новая задача
    
    yield
    
    # Останавливаем все при завершении
    logger.info("=" * 50)
    logger.info("[SHUTDOWN] ОСТАНОВКА Guardian Angel API")
    logger.info("=" * 50)
    
    await emulator_client.stop()
    emulator_task.cancel()
    archive_sender_task.cancel()  # Отменяем задачу почтальона
    
    try:
        await emulator_task
    except asyncio.CancelledError:
        pass
    
    try:
        await archive_sender_task
    except asyncio.CancelledError:
        pass


# ==================== СОЗДАНИЕ FASTAPI ПРИЛОЖЕНИЯ ====================

app = FastAPI(
    title="Guardian Angel API",
    version="4.2",
    description="Real-time CTG monitoring system with MIS integration",
    lifespan=lifespan
)

# Настройка CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # В продакшене указать конкретные домены
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ==================== API ENDPOINTS ====================

@app.get('/')
def root():
    """Корневой эндпоинт - статус системы"""
    return {
        'status': 'ok',
        'version': '4.2',
        'websocket_clients': len(manager.active_connections),
        'emulator_connected': emulator_client.reader is not None,
        'data_points_received': emulator_client.data_counter,
        'patients_with_clinical_data': len(patient_clinical_data)
    }


@app.get('/ctg_data')
def get_ctg_data(limit: int = 50):
    """Получить последние записи КТГ из базы данных"""
    try:
        db = DBManager()
        rows = db.get(limit)
        
        if not rows:
            logger.warning("База данных пуста")
            return {"message": "No data available", "data": []}
        
        result = []
        for r in rows:
            result.append({
                'id': r[0],
                'ts': r[1],
                'bpm_time': r[2],
                'bpm_value': r[3],
                'uterus_time': r[4],
                'uterus_value': r[5],
            })
        
        logger.info(f"Возвращено {len(result)} записей КТГ")
        return {"count": len(result), "data": result}
        
    except Exception as e:
        logger.error(f"Ошибка при получении данных КТГ: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get('/export')
def export_csv():
    """Экспортировать все данные в CSV файл"""
    try:
        db = DBManager()
        rows = db.get(sys.maxsize)
        
        if not rows:
            raise HTTPException(status_code=404, detail="No data to export")
        
        filename = f'export_{int(time.time())}.csv'
        path = os.path.join(os.getcwd(), filename)
        
        with open(path, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(['id', 'ts', 'bpm_time', 'bpm_value', 'uterus_time', 'uterus_value'])
            writer.writerows(rows)
        
        logger.info(f"Экспортировано {len(rows)} записей в {filename}")
        return FileResponse(path, media_type='text/csv', filename=filename)
        
    except Exception as e:
        logger.error(f"Ошибка при экспорте: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get('/predictions')
async def predictions_default():
    """Получить предсказания для сессии по умолчанию"""
    return await predictions("default")


@app.get('/predictions/{session_id}')
async def predictions(session_id: str = "default"):
    """Получить предсказания ML модели с учетом клинических данных"""
    try:
        # Проверяем наличие данных в БД
        db = DBManager()
        data_count = len(db.get(100))
        
        if data_count < 10:
            logger.warning(f"Недостаточно данных для анализа: {data_count} записей")
            return {
                "error": "Insufficient data",
                "message": f"Требуется минимум 10 записей, доступно: {data_count}",
                "session_id": session_id
            }
        
        # Получаем клинические данные
        clinical_data = patient_clinical_data.get(session_id)
        
        if clinical_data and clinical_data.get('risk_factors'):
            logger.info(f"Анализ для {session_id} с факторами риска: {clinical_data['risk_factors']}")
        
        # Выполняем анализ
        result = await prediction_service.analyze(
            clinical_data=clinical_data,
            include_graph_data=True
        )
        
        # Добавляем метаданные
        result['session_id'] = session_id
        result['clinical_data_applied'] = bool(clinical_data and clinical_data.get('risk_factors'))
        result['risk_factors_used'] = clinical_data.get('risk_factors', []) if clinical_data else []
        result['data_points_analyzed'] = data_count
        
        return result
        
    except Exception as e:
        logger.error(f"Ошибка при анализе: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/patient/{session_id}/clinical_data")
async def update_clinical_data(session_id: str, payload: ClinicalDataPayload):
    """Загрузить клинические данные пациента (эмуляция МИС)"""
    try:
        clinical_data = payload.dict()
        clinical_data['last_updated'] = datetime.now().isoformat()
        
        # Сохраняем данные в хранилище
        patient_clinical_data[session_id] = clinical_data
        
        logger.info(f"[UPDATED] Обновлены клинические данные для {session_id}")
        logger.info(f"  - ФИО: {clinical_data.get('patient_name', 'Не указано')}")
        logger.info(f"  - Срок беременности: {clinical_data.get('pregnancy_week', 'Не указан')} недель")
        logger.info(f"  - Факторов риска: {len(payload.risk_factors)}")
        
        # Уведомляем через WebSocket об обновлении клинических данных
        await manager.broadcast({
            "type": "clinical_data_updated",
            "session_id": session_id,
            "data": clinical_data
        })
        
        # Отправляем специальное сообщение об обновлении информации о пациенте
        await manager.broadcast({
            "type": "patient_info_updated",
            "session_id": session_id,
            "name": clinical_data.get('patient_name', 'Не указано'),
            "week": clinical_data.get('pregnancy_week')
        })
        
        # Запускаем анализ с новыми данными
        await emulator_client.run_prediction_analysis(session_id)
        
        return {
            "status": "ok",
            "session_id": session_id,
            "patient_name": clinical_data.get('patient_name'),
            "pregnancy_week": clinical_data.get('pregnancy_week'),
            "risk_factors_count": len(payload.risk_factors),
            "data_received": clinical_data
        }
        
    except Exception as e:
        logger.error(f"Ошибка при обновлении клинических данных: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/patient/{session_id}/clinical_data", response_model=PatientInfo)
async def get_clinical_data(session_id: str):
    """Получить клинические данные пациента"""
    if session_id not in patient_clinical_data:
        raise HTTPException(
            status_code=404,
            detail=f"Clinical data for session {session_id} not found"
        )
    
    return PatientInfo(session_id=session_id, **patient_clinical_data[session_id])


@app.delete("/patient/{session_id}/clinical_data")
async def clear_clinical_data(session_id: str):
    """Удалить клинические данные пациента"""
    if session_id in patient_clinical_data:
        del patient_clinical_data[session_id]
        
        await manager.broadcast({
            "type": "clinical_data_cleared",
            "session_id": session_id
        })
        
        # Отправляем обновление о сбросе информации пациента
        await manager.broadcast({
            "type": "patient_info_updated",
            "session_id": session_id,
            "name": "Не указано",
            "week": None
        })
        
        logger.info(f"Удалены клинические данные для {session_id}")
        return {"status": "ok", "message": f"Clinical data for {session_id} cleared"}
    else:
        raise HTTPException(
            status_code=404,
            detail=f"Clinical data for session {session_id} not found"
        )


@app.get("/patient/sessions")
async def get_all_patient_sessions():
    """Получить список всех сессий с клиническими данными"""
    sessions = []
    for session_id, data in patient_clinical_data.items():
        sessions.append({
            "session_id": session_id,
            "patient_name": data.get('patient_name', 'Не указано'),
            "risk_factors_count": len(data.get('risk_factors', [])),
            "patient_age": data.get('patient_age'),
            "pregnancy_week": data.get('pregnancy_week'),
            "last_updated": data.get('last_updated', 'unknown')
        })
    
    return {
        "total_sessions": len(sessions),
        "sessions": sessions
    }


@app.post("/demo/load_sample_patients")
async def load_sample_patients():
    """Загрузить демонстрационные данные пациентов"""
    sample_patients = {
        "patient_001": {
            "patient_name": "Иванова Мария Петровна",
            "risk_factors": ["Гестационный диабет", "Ожирение"],
            "patient_age": 38,
            "pregnancy_week": 36
        },
        "patient_002": {
            "patient_name": "Петрова Елена Сергеевна",
            "risk_factors": ["Преэклампсия", "Многоплодная беременность"],
            "patient_age": 29,
            "pregnancy_week": 34
        },
        "patient_003": {
            "patient_name": "Сидорова Анна Ивановна",
            "risk_factors": [],
            "patient_age": 25,
            "pregnancy_week": 39
        }
    }
    
    for session_id, data in sample_patients.items():
        data['last_updated'] = datetime.now().isoformat()
        patient_clinical_data[session_id] = data
    
    logger.info(f"Загружены демо-данные для {len(sample_patients)} пациентов")
    
    # Отправляем уведомление о загрузке демо-данных
    for session_id, data in sample_patients.items():
        await manager.broadcast({
            "type": "patient_info_updated",
            "session_id": session_id,
            "name": data.get('patient_name', 'Не указано'),
            "week": data.get('pregnancy_week')
        })
    
    return {
        "status": "ok",
        "message": "Sample patients loaded",
        "loaded_patients": list(sample_patients.keys())
    }


@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket эндпоинт для real-time обновлений"""
    await manager.connect(websocket)
    
    try:
        # Отправляем приветственное сообщение
        await websocket.send_json({
            "type": "welcome",
            "message": "Connected to Guardian Angel real-time stream",
            "server_time": datetime.now().isoformat()
        })
        
        # Отправляем текущий статус
        await websocket.send_json({
            "type": "status",
            "emulator_connected": emulator_client.reader is not None,
            "data_points": emulator_client.data_counter
        })
        
        # Отправляем информацию о текущем пациенте
        current_session = emulator_client.current_session_id
        if current_session in patient_clinical_data:
            patient_data = patient_clinical_data[current_session]
            await websocket.send_json({
                "type": "patient_info_updated",
                "session_id": current_session,
                "name": patient_data.get('patient_name', 'Не указано'),
                "week": patient_data.get('pregnancy_week')
            })
        else:
            # Если данных нет, отправляем значения по умолчанию
            await websocket.send_json({
                "type": "patient_info_updated",
                "session_id": current_session,
                "name": "Не указано",
                "week": None
            })
        
        # Держим соединение открытым
        while True:
            data = await websocket.receive_text()
            
            # Обработка команд от клиента
            if data == "ping":
                await websocket.send_text("pong")
            
            elif data == "status":
                await websocket.send_json({
                    "type": "status",
                    "emulator_connected": emulator_client.reader is not None,
                    "total_clients": len(manager.active_connections),
                    "data_points": emulator_client.data_counter
                })
            
            elif data.startswith("session:"):
                # Смена активной сессии
                new_session = data.split(":", 1)[1]
                emulator_client.current_session_id = new_session
                logger.info(f"Сессия изменена на: {new_session}")
                
                await websocket.send_json({
                    "type": "session_switched",
                    "session_id": new_session
                })
                
                # Отправляем информацию о пациенте для новой сессии
                if new_session in patient_clinical_data:
                    patient_data = patient_clinical_data[new_session]
                    await websocket.send_json({
                        "type": "patient_info_updated",
                        "session_id": new_session,
                        "name": patient_data.get('patient_name', 'Не указано'),
                        "week": patient_data.get('pregnancy_week')
                    })
                
    except WebSocketDisconnect:
        await manager.disconnect(websocket)
    except Exception as e:
        logger.error(f"WebSocket error: {e}")
        await manager.disconnect(websocket)


@app.get('/status')
async def get_status():
    """Получить полный статус системы"""
    try:
        db = DBManager()
        total_records = len(db.get(sys.maxsize))
        
        return {
            "system": "Guardian Angel API",
            "version": "4.2",
            "emulator": {
                "connected": emulator_client.reader is not None,
                "host": f"{EMULATOR_HOST}:{EMULATOR_PORT}",
                "data_received": emulator_client.data_counter
            },
            "database": {
                "path": DB_PATH,
                "total_records": total_records
            },
            "websocket": {
                "active_clients": len(manager.active_connections)
            },
            "clinical_data": {
                "sessions_count": len(patient_clinical_data),
                "sessions": list(patient_clinical_data.keys())
            },
            "current_session": emulator_client.current_session_id,
            "current_patient": patient_clinical_data.get(
                emulator_client.current_session_id, {}
            ).get('patient_name', 'Не указано'),
            "server_time": datetime.now().isoformat()
        }
    except Exception as e:
        logger.error(f"Ошибка при получении статуса: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/session/current")
async def get_current_session():
    """Получить информацию о текущей сессии"""
    db = DBManager()
    record_count = len(db.get(100))
    
    clinical_data = patient_clinical_data.get(
        emulator_client.current_session_id, 
        {}
    )
    
    return {
        "session_id": emulator_client.current_session_id,
        "patient_name": clinical_data.get("patient_name", "Не указано"),
        "pregnancy_week": clinical_data.get("pregnancy_week"),
        "risk_factors": clinical_data.get("risk_factors", []),
        "records_collected": record_count,
        "data_points_received": emulator_client.data_counter,
        "emulator_connected": emulator_client.reader is not None
    }


@app.post("/session/export-preview")
async def preview_export_data():
    """
    Предпросмотр данных, которые будут архивированы при завершении сессии.
    Полезно для проверки перед финальной архивацией.
    """
    db = DBManager()
    all_records = db.get(sys.maxsize)
    
    if not all_records:
        return {
            "status": "no_data",
            "message": "No data to preview"
        }
    
    # Показываем только первые и последние 5 записей для предпросмотра
    preview_records = []
    if len(all_records) <= 10:
        preview_records = all_records
    else:
        preview_records = all_records[:5] + all_records[-5:]
    
    formatted_preview = []
    for record in preview_records:
        formatted_preview.append({
            "id": record[0],
            "timestamp": record[1],
            "bpm_value": record[3],
            "uterus_value": record[5]
        })
    
    clinical_data = patient_clinical_data.get(
        emulator_client.current_session_id, 
        {}
    )
    
    return {
        "session_id": emulator_client.current_session_id,
        "total_records": len(all_records),
        "patient_info": {
            "name": clinical_data.get("patient_name", "Не указано"),
            "pregnancy_week": clinical_data.get("pregnancy_week"),
            "risk_factors": clinical_data.get("risk_factors", [])
        },
        "data_preview": formatted_preview,
        "preview_note": f"Showing {len(formatted_preview)} of {len(all_records)} records"
    }


@app.post("/session/end")
async def end_session(request: SessionEndRequest):
    """
    Завершить текущую сессию мониторинга (отказоустойчивая версия):
    1. Собрать все данные
    2. Сохранить в локальную очередь
    3. Немедленно очистить БД для нового пациента
    4. Фоновый процесс отправит архив когда появится сеть
    """
    try:
        session_id = emulator_client.current_session_id
        logger.info(f"[SESSION END] Завершение сессии {session_id}")
        
        # ===== 1. СБОР ДАННЫХ =====
        db = DBManager()
        
        # Получаем статистику перед очисткой
        stats = db.get_session_statistics() if hasattr(db, 'get_session_statistics') else {}
        
        # Получаем все записи КТГ
        all_ctg_records = db.get(sys.maxsize)
        
        if not all_ctg_records:
            logger.warning("Нет данных для архивации")
            return {
                "status": "no_data",
                "message": "No data to archive",
                "session_id": session_id
            }
        
        # Форматируем записи
        ctg_data_formatted = []
        for record in all_ctg_records:
            ctg_data_formatted.append({
                "id": record[0],
                "timestamp": record[1],
                "bpm_time": record[2],
                "bpm_value": record[3],
                "uterus_time": record[4],
                "uterus_value": record[5]
            })
        
        # Получаем клинические данные
        clinical_data = patient_clinical_data.get(
            session_id, 
            {"risk_factors": [], "patient_name": "Не указано"}
        )
        
        # ===== 2. ФОРМИРОВАНИЕ АРХИВА =====
        archive_payload = {
            "session_id": session_id,
            "metadata": {
                "archive_server_url": request.archive_server_url,  # Сохраняем URL в архив
                "created_at": datetime.now().isoformat(),
                "doctor_name": request.doctor_name,
                "session_notes": request.session_notes
            },
            "session_info": {
                "start_time": ctg_data_formatted[0]["timestamp"] if ctg_data_formatted else None,
                "end_time": datetime.now().isoformat(),
                "total_records": len(ctg_data_formatted),
                "duration_seconds": stats.get("duration_seconds", 0),
                "avg_bpm": stats.get("avg_bpm", 0),
                "avg_uterus": stats.get("avg_uterus", 0)
            },
            "patient_info": {
                "name": clinical_data.get("patient_name", "Не указано"),
                "age": clinical_data.get("patient_age"),
                "pregnancy_week": clinical_data.get("pregnancy_week"),
                "risk_factors": clinical_data.get("risk_factors", []),
                "medications": clinical_data.get("medications", []),
                "previous_pregnancies": clinical_data.get("previous_pregnancies")
            },
            "ctg_records": ctg_data_formatted
        }
        
        # ===== 3. СОХРАНЕНИЕ В ОЧЕРЕДЬ =====
        os.makedirs(ARCHIVES_QUEUE_DIR, exist_ok=True)
        
        # Генерируем уникальное имя файла с timestamp для правильной сортировки
        timestamp = int(time.time() * 1000)  # Миллисекунды для уникальности
        archive_filename = f"archive_{session_id}_{timestamp}.json"
        archive_path = os.path.join(ARCHIVES_QUEUE_DIR, archive_filename)
        
        # Сохраняем архив
        with open(archive_path, 'w', encoding='utf-8') as f:
            json.dump(archive_payload, f, indent=2, default=str)
        
        logger.info(f"[QUEUE] Архив сохранен в очередь: {archive_filename}")
        
        # ===== 4. НЕМЕДЛЕННАЯ ОЧИСТКА ДАННЫХ =====
        cleared_records = db.clear_data()
        logger.info(f"[CLEANUP] Очищено {cleared_records} записей из БД")
        
        # Очищаем клинические данные
        if session_id in patient_clinical_data:
            del patient_clinical_data[session_id]
            logger.info(f"[CLEANUP] Очищены клинические данные для сессии {session_id}")
        
        # Сбрасываем счетчик
        emulator_client.data_counter = 0
        
        # ===== 5. СОЗДАНИЕ НОВОЙ СЕССИИ =====
        new_session_id = f"session_{int(time.time())}"
        emulator_client.current_session_id = new_session_id
        
        # Инициализируем данные для новой сессии
        patient_clinical_data[new_session_id] = {
            "risk_factors": [],
            "patient_name": "Не указано",
            "pregnancy_week": None
        }
        
        logger.info(f"[NEW SESSION] Создана новая сессия: {new_session_id}")
        
        # ===== 6. УВЕДОМЛЕНИЯ ЧЕРЕЗ WEBSOCKET =====
        await manager.broadcast({
            "type": "session_ended",
            "session_id": session_id,
            "message": "Сессия завершена, архив поставлен в очередь на отправку",
            "archived_records": len(ctg_data_formatted),
            "queue_status": "pending"
        })
        
        await manager.broadcast({
            "type": "new_session_started",
            "session_id": new_session_id,
            "message": "Начата новая сессия мониторинга"
        })
        
        # Проверяем статус очереди
        queue_files = glob.glob(os.path.join(ARCHIVES_QUEUE_DIR, "*.json"))
        
        return {
            "status": "success",
            "message": "Сессия завершена, данные очищены, архив поставлен в очередь",
            "archived_session": {
                "session_id": session_id,
                "records_count": len(ctg_data_formatted),
                "archive_filename": archive_filename,
                "queue_position": len(queue_files)
            },
            "new_session": {
                "session_id": new_session_id,
                "status": "ready"
            },
            "queue_info": {
                "total_in_queue": len(queue_files),
                "message": "Архив будет отправлен автоматически при наличии соединения"
            }
        }
        
    except Exception as e:
        logger.error(f"[SESSION END ERROR] Критическая ошибка: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/archives/queue")
async def get_archives_queue():
    """Получить информацию об очереди архивов"""
    try:
        # Архивы в очереди
        pending_files = glob.glob(os.path.join(ARCHIVES_QUEUE_DIR, "*.json"))
        
        # Архивы с ошибками
        error_dir = os.path.join(ARCHIVES_QUEUE_DIR, "errors")
        error_files = glob.glob(os.path.join(error_dir, "*.json")) if os.path.exists(error_dir) else []
        
        # Успешно отправленные
        sent_dir = os.path.join(ARCHIVES_QUEUE_DIR, "sent")
        sent_files = glob.glob(os.path.join(sent_dir, "*.json")) if os.path.exists(sent_dir) else []
        
        # Детальная информация о файлах в очереди
        pending_details = []
        for file_path in sorted(pending_files):
            file_stat = os.stat(file_path)
            file_size = file_stat.st_size
            
            # Пытаемся прочитать session_id из файла
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    session_id = data.get("session_id", "unknown")
                    server_url = data.get("metadata", {}).get("archive_server_url", "unknown")
            except:
                session_id = "error"
                server_url = "error"
            
            pending_details.append({
                "filename": os.path.basename(file_path),
                "session_id": session_id,
                "server_url": server_url,
                "size_bytes": file_size,
                "created": datetime.fromtimestamp(file_stat.st_ctime).isoformat()
            })
        
        return {
            "queue_status": {
                "pending": len(pending_files),
                "errors": len(error_files),
                "sent": len(sent_files)
            },
            "pending_archives": pending_details,
            "next_check": f"in {ARCHIVE_SENDER_INTERVAL} seconds"
        }
        
    except Exception as e:
        logger.error(f"Ошибка при получении статуса очереди: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/archives/retry/{filename}")
async def retry_archive_send(filename: str):
    """Повторить попытку отправки конкретного архива"""
    try:
        # Проверяем, есть ли файл в папке ошибок
        error_path = os.path.join(ARCHIVES_QUEUE_DIR, "errors", filename)
        queue_path = os.path.join(ARCHIVES_QUEUE_DIR, filename)
        
        if os.path.exists(error_path):
            # Перемещаем обратно в очередь
            os.rename(error_path, queue_path)
            logger.info(f"[RETRY] Архив {filename} возвращен в очередь")
            
            return {
                "status": "success",
                "message": f"Archive {filename} moved back to queue for retry"
            }
        else:
            raise HTTPException(status_code=404, detail=f"Archive {filename} not found in errors")
            
    except Exception as e:
        logger.error(f"Ошибка при повторной отправке: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.delete("/archives/clear-sent")
async def clear_sent_archives():
    """Очистить папку с успешно отправленными архивами"""
    try:
        sent_dir = os.path.join(ARCHIVES_QUEUE_DIR, "sent")
        if os.path.exists(sent_dir):
            files = glob.glob(os.path.join(sent_dir, "*.json"))
            for file in files:
                os.remove(file)
            
            return {
                "status": "success",
                "message": f"Cleared {len(files)} sent archives"
            }
        else:
            return {
                "status": "success",
                "message": "No sent archives to clear"
            }
            
    except Exception as e:
        logger.error(f"Ошибка при очистке отправленных архивов: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ==================== ТОЧКА ВХОДА ====================

if __name__ == "__main__":
    import uvicorn
    
    # Запускаем сервер
    uvicorn.run(
        "guardian_angel.api:app",  # Используем полный путь к модулю
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )


================================================================================
Файл: C:\Users\User\Desktop\gotovo\integrated_project\device_emulator\main.py
================================================================================

import csv
import json
import os
import socket
import time

HOST = '127.0.0.1'
PORT = 8081  # Изменен порт, чтобы избежать конфликта с системными ограничениями
SENDING_INTERVAL_SECONDS = 1

DATA_PATH = 'C:/Users/User/Desktop/ИТЭЛМА_ЛЦТ/ЛЦТ _НПП _ИТЭЛМА_'
DATA_MAX_FILES_TO_LOAD = 100
CSV_FIELDS_SEPARATOR = ','

TEST_DATA = []


def load_test_data():
    result = []
    files_count = 0
    for root, dirs, files in os.walk(DATA_PATH):
        for file in (x for x in files if x.lower().endswith('.csv')):
            base, ctg_type = os.path.split(root)

            # --- ВОТ ЭТА ПРОВЕРКА ---
            if ctg_type not in ['bpm', 'uterus']:
                continue  # Пропускаем этот файл и идем к следующему
            # ------------------------

            base, patient_id = os.path.split(base)
            base, disease_type = os.path.split(base)

            file_path = os.path.join(root, file)
            with open(file_path, newline='') as csvfile:
                rows = []
                csv_reader = csv.reader(csvfile, delimiter=CSV_FIELDS_SEPARATOR)
                for row in (x for x in csv_reader if len(x) == 2):
                    if is_number(row[0]) and is_number(row[1]):
                        rows.append([row[0], row[1]])
                result.append((disease_type, patient_id, ctg_type, rows))
                print(f'File {file_path} successfully loaded')
                files_count += 1
                if files_count >= DATA_MAX_FILES_TO_LOAD:
                    return result
    return result


def read_test_data():
    while True:
        yield from TEST_DATA


def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False


def start_server():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((HOST, PORT))
        s.listen()
        print(f'Server started {HOST}:{PORT}, sending interval {SENDING_INTERVAL_SECONDS} seconds')
        conn, addr = s.accept()
        with conn:
            for test_data_value in read_test_data():
                try:
                    bpm_files_len = len(test_data_value['bpm'])
                    uterus_files_len = len(test_data_value['uterus'])

                    for i in range(0, min(bpm_files_len, uterus_files_len) - 1):
                        bpm_len = len(test_data_value['bpm'][i])
                        uterus_len = len(test_data_value['uterus'][i])

                        for k in range(0, min(bpm_len, uterus_len) - 1):
                            message = json.dumps({
                                'bpm': [test_data_value['bpm'][i][k][0], test_data_value['bpm'][i][k][1]],
                                'uterus': [test_data_value['uterus'][i][k][0], test_data_value['uterus'][i][k][1]]
                            }).encode('utf-8')
                            print(f'Sending message: {message}')
                            conn.sendall(message + b'\n')
                            time.sleep(SENDING_INTERVAL_SECONDS)

                except Exception as e:
                    print(f"Error: {e}")
                    conn, addr = s.accept()


def transform_data(source_data):
    result = {}

    for disease_type, patient_id, ctg_type, ctg_values in source_data:
        patient = f'{disease_type}_{patient_id}'
        if patient not in result:
            result[patient] = {'disease_type': disease_type, 'patient_id': patient_id, 'bpm': [], 'uterus': []}

        result[patient][ctg_type].append(ctg_values)

    return list(result.values())


if __name__ == '__main__':
    data = load_test_data()
    TEST_DATA = transform_data(data)
    start_server()

